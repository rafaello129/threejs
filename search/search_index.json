{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"Curso/1.%20Introducci%C3%B3n%20a%20Three.js/","title":"1. Introducci\u00f3n a Three.js","text":""},{"location":"Curso/1.%20Introducci%C3%B3n%20a%20Three.js/#11-que-es-threejs","title":"1.1 \u00bfQu\u00e9 es Three.js?","text":"<p>Three.js es una biblioteca de JavaScript que facilita la creaci\u00f3n y visualizaci\u00f3n de gr\u00e1ficos 3D en el navegador web utilizando WebGL. WebGL es una API de JavaScript que permite renderizar gr\u00e1ficos interactivos en 2D y 3D sin necesidad de plugins adicionales. Sin embargo, trabajar directamente con WebGL puede ser complejo debido a su bajo nivel. Aqu\u00ed es donde Three.js entra en juego, proporcionando una abstracci\u00f3n m\u00e1s amigable y simplificando tareas comunes como la creaci\u00f3n de escenas, c\u00e1maras, luces y objetos 3D.</p>"},{"location":"Curso/1.%20Introducci%C3%B3n%20a%20Three.js/#12-instalacion-y-configuracion-basica","title":"1.2 Instalaci\u00f3n y configuraci\u00f3n b\u00e1sica","text":"<p>Para comenzar a trabajar con Three.js, es necesario configurar un entorno de desarrollo adecuado. A continuaci\u00f3n, se detallan los pasos para instalar y configurar Three.js tanto de manera local como utilizando un gestor de paquetes como npm.</p>"},{"location":"Curso/1.%20Introducci%C3%B3n%20a%20Three.js/#121-metodos-de-instalacion","title":"1.2.1 M\u00e9todos de instalaci\u00f3n","text":"<p>Existen varias formas de incluir Three.js en tu proyecto:</p> <ol> <li>Uso de un CDN (Content Delivery Network):    Esta es la forma m\u00e1s sencilla de empezar, ideal para proyectos peque\u00f1os o para probar r\u00e1pidamente.</li> </ol> <pre><code>   &lt;!DOCTYPE html&gt;\n   &lt;html lang=\"es\"&gt;\n   &lt;head&gt;\n       &lt;meta charset=\"UTF-8\"&gt;\n       &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n       &lt;title&gt;Three.js con CDN&lt;/title&gt;\n   &lt;/head&gt;\n   &lt;body&gt;\n       &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js\"&gt;&lt;/script&gt;\n       &lt;script&gt;\n           // C\u00f3digo Three.js aqu\u00ed\n           const scene = new THREE.Scene();\n           const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);\n           const renderer = new THREE.WebGLRenderer();\n           renderer.setSize(window.innerWidth, window.innerHeight);\n           document.body.appendChild(renderer.domElement);\n\n           const geometry = new THREE.BoxGeometry();\n           const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\n           const cube = new THREE.Mesh(geometry, material);\n           scene.add(cube);\n\n           camera.position.z = 5;\n\n           function animate() {\n               requestAnimationFrame(animate);\n               cube.rotation.x += 0.01;\n               cube.rotation.y += 0.01;\n               renderer.render(scene, camera);\n           }\n\n           animate();\n       &lt;/script&gt;\n   &lt;/body&gt;\n   &lt;/html&gt;\n   ```\n\n2. **Descarga directa de Three.js:**\n   Puedes descargar el archivo `three.min.js` desde el [sitio oficial de Three.js](https://threejs.org/) y enlazarlo localmente en tu proyecto.\n\n   - Descarga el archivo desde [Three.js Builds](https://threejs.org/build/).\n   - Coloca el archivo en una carpeta de tu proyecto, por ejemplo, `js/`.\n   - Enl\u00e1zalo en tu HTML:\n\n```html\n     &lt;script src=\"js/three.min.js\"&gt;&lt;/script&gt;\n</code></pre> <ol> <li> <p>Uso de npm (Node Package Manager):    Ideal para proyectos m\u00e1s grandes y que requieren gesti\u00f3n de dependencias.</p> </li> <li> <p>Paso 1: Inicializa un proyecto npm si a\u00fan no lo has hecho.</p> <p><code>bash  npm init -y</code></p> </li> <li> <p>Paso 2: Instala Three.js.</p> <p><code>bash  npm install three</code></p> </li> <li> <p>Paso 3: Configura tu proyecto para usar m\u00f3dulos ES6 o una herramienta de empaquetado como Webpack.</p> </li> <li> <p>Ejemplo de uso con m\u00f3dulos ES6:</p> </li> </ol> <pre><code>     // main.js\n     import * as THREE from 'three';\n\n     const scene = new THREE.Scene();\n     const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);\n     const renderer = new THREE.WebGLRenderer();\n     renderer.setSize(window.innerWidth, window.innerHeight);\n     document.body.appendChild(renderer.domElement);\n\n     const geometry = new THREE.BoxGeometry();\n     const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\n     const cube = new THREE.Mesh(geometry, material);\n     scene.add(cube);\n\n     camera.position.z = 5;\n\n     function animate() {\n         requestAnimationFrame(animate);\n         cube.rotation.x += 0.01;\n         cube.rotation.y += 0.01;\n         renderer.render(scene, camera);\n     }\n\n     animate();\n</code></pre> <ul> <li> <p>Configura un servidor de desarrollo: Puedes usar herramientas como <code>webpack-dev-server</code> o <code>vite</code> para servir tu proyecto.</p> <p><code>bash  npm install --save-dev webpack webpack-cli webpack-dev-server</code></p> </li> </ul>"},{"location":"Curso/1.%20Introducci%C3%B3n%20a%20Three.js/#122-requisitos-del-entorno","title":"1.2.2 Requisitos del entorno","text":"<ul> <li>Servidor local (opcional pero recomendado): Algunos navegadores imponen restricciones al cargar archivos locales (por ejemplo, texturas). Usar un servidor local evita estos problemas. Puedes usar extensiones como Live Server en Visual Studio Code o herramientas como <code>http-server</code> de npm.</li> </ul> <p><code>bash   npm install -g http-server   http-server</code></p> <ul> <li>Node.js y npm (si usas gestores de paquetes): Para proyectos que requieran empaquetadores, gestores de dependencias u otras herramientas, aseg\u00farate de tener Node.js y npm instalados. Puedes descargarlos desde nodejs.org.</li> </ul>"},{"location":"Curso/1.%20Introducci%C3%B3n%20a%20Three.js/#13-preparacion-del-entorno-html-javascript-y-nodejs-si-se-requiere","title":"1.3 Preparaci\u00f3n del entorno: HTML, JavaScript y Node.js (si se requiere)","text":"<p>A continuaci\u00f3n, se detalla c\u00f3mo preparar un entorno b\u00e1sico para trabajar con Three.js, tanto si decides usar un enfoque sencillo con HTML y JavaScript puro como si optas por un entorno m\u00e1s avanzado utilizando Node.js y m\u00f3dulos ES6.</p>"},{"location":"Curso/1.%20Introducci%C3%B3n%20a%20Three.js/#131-proyecto-basico-con-html-y-javascript","title":"1.3.1 Proyecto b\u00e1sico con HTML y JavaScript","text":"<p>Este enfoque es ideal para principiantes y proyectos peque\u00f1os.</p> <ol> <li>Estructura de carpetas:</li> </ol> <pre><code>   mi-proyecto-threejs/\n   \u251c\u2500\u2500 index.html\n   \u2514\u2500\u2500 js/\n       \u2514\u2500\u2500 three.min.js\n</code></pre> <ol> <li>Contenido de <code>index.html</code>:</li> </ol> <pre><code>   &lt;!DOCTYPE html&gt;\n   &lt;html lang=\"es\"&gt;\n   &lt;head&gt;\n       &lt;meta charset=\"UTF-8\"&gt;\n       &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n       &lt;title&gt;Mi Primera Escena con Three.js&lt;/title&gt;\n       &lt;style&gt;\n           body { margin: 0; }\n           canvas { display: block; }\n       &lt;/style&gt;\n   &lt;/head&gt;\n   &lt;body&gt;\n       &lt;!-- Enlace a Three.js --&gt;\n       &lt;script src=\"js/three.min.js\"&gt;&lt;/script&gt;\n       &lt;script&gt;\n           // Crear la escena\n           const scene = new THREE.Scene();\n\n           // Crear la c\u00e1mara\n           const camera = new THREE.PerspectiveCamera(\n               75, // Campo de visi\u00f3n\n               window.innerWidth / window.innerHeight, // Aspect ratio\n               0.1, // Near clipping plane\n               1000 // Far clipping plane\n           );\n\n           // Crear el renderizador\n           const renderer = new THREE.WebGLRenderer();\n           renderer.setSize(window.innerWidth, window.innerHeight);\n           document.body.appendChild(renderer.domElement);\n\n           // Crear un cubo\n           const geometry = new THREE.BoxGeometry();\n           const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\n           const cube = new THREE.Mesh(geometry, material);\n           scene.add(cube);\n\n           // Posicionar la c\u00e1mara\n           camera.position.z = 5;\n\n           // Funci\u00f3n de animaci\u00f3n\n           function animate() {\n               requestAnimationFrame(animate);\n\n               // Rotar el cubo\n               cube.rotation.x += 0.01;\n               cube.rotation.y += 0.01;\n\n               // Renderizar la escena\n               renderer.render(scene, camera);\n           }\n\n           animate();\n\n           // Manejar el redimensionamiento de la ventana\n           window.addEventListener('resize', () =&gt; {\n               const width = window.innerWidth;\n               const height = window.innerHeight;\n               renderer.setSize(width, height);\n               camera.aspect = width / height;\n               camera.updateProjectionMatrix();\n           });\n       &lt;/script&gt;\n   &lt;/body&gt;\n   &lt;/html&gt;\n</code></pre> <ol> <li> <p>Ejecutar el proyecto:</p> </li> <li> <p>Abre el archivo <code>index.html</code> en tu navegador.</p> </li> <li>Deber\u00edas ver un cubo verde girando en el centro de la pantalla.</li> </ol>"},{"location":"Curso/1.%20Introducci%C3%B3n%20a%20Three.js/#132-proyecto-avanzado-con-nodejs-y-modulos-es6","title":"1.3.2 Proyecto avanzado con Node.js y m\u00f3dulos ES6","text":"<p>Este enfoque es m\u00e1s adecuado para proyectos complejos que requieren una estructura modular, empaquetado y herramientas de desarrollo avanzadas.</p> <ol> <li>Inicializar el proyecto:</li> </ol> <pre><code>   mkdir mi-proyecto-threejs\n   cd mi-proyecto-threejs\n   npm init -y\n</code></pre> <ol> <li>Instalar Three.js y otras dependencias (opcional):</li> </ol> <p><code>bash    npm install three</code></p> <ol> <li> <p>Configurar herramientas de desarrollo:</p> </li> <li> <p>Uso de Webpack (opcional pero recomendado):</p> <p><code>bash  npm install --save-dev webpack webpack-cli webpack-dev-server</code></p> </li> <li> <p>Crear archivos de configuraci\u00f3n:</p> <ul> <li><code>webpack.config.js</code>:</li> </ul> </li> </ol> <pre><code>       const path = require('path');\n\n       module.exports = {\n           entry: './src/index.js',\n           output: {\n               filename: 'bundle.js',\n               path: path.resolve(__dirname, 'dist'),\n           },\n           devServer: {\n               contentBase: path.join(__dirname, 'dist'),\n               compress: true,\n               port: 9000,\n           },\n           module: {\n               rules: [\n                   {\n                       test: /\\.js$/,\n                       exclude: /node_modules/,\n                       use: {\n                           loader: 'babel-loader',\n                           options: {\n                               presets: ['@babel/preset-env'],\n                           },\n                       },\n                   },\n               ],\n           },\n           mode: 'development',\n       };\n</code></pre> <ul> <li> <p>Instalar Babel (para compatibilidad):</p> <p><code>bash    npm install --save-dev babel-loader @babel/core @babel/preset-env</code></p> <ul> <li>Crear <code>.babelrc</code>:</li> </ul> </li> </ul> <pre><code>       {\n           \"presets\": [\"@babel/preset-env\"]\n       }\n</code></pre> <ol> <li>Estructura de carpetas:</li> </ol> <pre><code>   mi-proyecto-threejs/\n   \u251c\u2500\u2500 dist/\n   \u2502   \u2514\u2500\u2500 index.html\n   \u251c\u2500\u2500 src/\n   \u2502   \u2514\u2500\u2500 index.js\n   \u251c\u2500\u2500 package.json\n   \u251c\u2500\u2500 webpack.config.js\n   \u2514\u2500\u2500 .babelrc\n</code></pre> <ol> <li>Contenido de <code>src/index.js</code>:</li> </ol> <pre><code>   import * as THREE from 'three';\n\n   // Crear la escena\n   const scene = new THREE.Scene();\n\n   // Crear la c\u00e1mara\n   const camera = new THREE.PerspectiveCamera(\n       75,\n       window.innerWidth / window.innerHeight,\n       0.1,\n       1000\n   );\n\n   // Crear el renderizador\n   const renderer = new THREE.WebGLRenderer({ antialias: true });\n   renderer.setSize(window.innerWidth, window.innerHeight);\n   document.body.appendChild(renderer.domElement);\n\n   // Crear un cubo\n   const geometry = new THREE.BoxGeometry();\n   const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\n   const cube = new THREE.Mesh(geometry, material);\n   scene.add(cube);\n\n   // Posicionar la c\u00e1mara\n   camera.position.z = 5;\n\n   // Funci\u00f3n de animaci\u00f3n\n   function animate() {\n       requestAnimationFrame(animate);\n\n       // Rotar el cubo\n       cube.rotation.x += 0.01;\n       cube.rotation.y += 0.01;\n\n       // Renderizar la escena\n       renderer.render(scene, camera);\n   }\n\n   animate();\n\n   // Manejar el redimensionamiento de la ventana\n   window.addEventListener('resize', () =&gt; {\n       const width = window.innerWidth;\n       const height = window.innerHeight;\n       renderer.setSize(width, height);\n       camera.aspect = width / height;\n       camera.updateProjectionMatrix();\n   });\n</code></pre> <ol> <li>Contenido de <code>dist/index.html</code>:</li> </ol> <pre><code>   &lt;!DOCTYPE html&gt;\n   &lt;html lang=\"es\"&gt;\n   &lt;head&gt;\n       &lt;meta charset=\"UTF-8\"&gt;\n       &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n       &lt;title&gt;Mi Proyecto Three.js&lt;/title&gt;\n       &lt;style&gt;\n           body { margin: 0; }\n           canvas { display: block; }\n       &lt;/style&gt;\n   &lt;/head&gt;\n   &lt;body&gt;\n       &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;\n   &lt;/body&gt;\n   &lt;/html&gt;\n   ```\n\n7. **Agregar scripts al `package.json`:**\n\n   ```json\n   \"scripts\": {\n       \"start\": \"webpack serve --open\",\n       \"build\": \"webpack\"\n   }\n</code></pre> <ol> <li> <p>Ejecutar el proyecto:</p> </li> <li> <p>Inicia el servidor de desarrollo:</p> <p><code>bash  npm run start</code></p> </li> <li> <p>Se abrir\u00e1 autom\u00e1ticamente una ventana en tu navegador en <code>http://localhost:9000</code> mostrando el cubo giratorio.</p> </li> </ol>"},{"location":"Curso/2.%20Estructura%20B%C3%A1sica%20de%20una%20Escena%20en%20Three.js/","title":"2. Estructura B\u00e1sica de una Escena en Three.js","text":""},{"location":"Curso/2.%20Estructura%20B%C3%A1sica%20de%20una%20Escena%20en%20Three.js/#21-componentes-principales-de-una-escena","title":"2.1 Componentes Principales de una Escena","text":"<p>Para crear una escena 3D en Three.js, necesitas comprender y configurar tres componentes fundamentales:</p> <ol> <li>Escena (<code>THREE.Scene</code>)</li> <li>C\u00e1mara (<code>THREE.Camera</code>)</li> <li>Renderizador (<code>THREE.Renderer</code>)</li> </ol> <p>Estos componentes trabajan en conjunto para definir qu\u00e9 se muestra en la pantalla, desde qu\u00e9 perspectiva y c\u00f3mo se renderiza visualmente.</p>"},{"location":"Curso/2.%20Estructura%20B%C3%A1sica%20de%20una%20Escena%20en%20Three.js/#22-descripcion-de-los-componentes","title":"2.2 Descripci\u00f3n de los Componentes","text":""},{"location":"Curso/2.%20Estructura%20B%C3%A1sica%20de%20una%20Escena%20en%20Three.js/#221-escena-threescene","title":"2.2.1 Escena (<code>THREE.Scene</code>)","text":"<p>La escena es el contenedor principal donde se agregan todos los objetos, luces y otros elementos 3D. Act\u00faa como un espacio tridimensional donde se organiza todo lo que se desea visualizar.</p> <p>Caracter\u00edsticas clave:</p> <ul> <li>Contenedor de objetos: Puedes agregar mallas (<code>Mesh</code>), luces (<code>Light</code>), c\u00e1maras adicionales, y m\u00e1s.</li> <li>Jerarqu\u00eda: Utiliza una estructura de \u00e1rbol donde los objetos pueden contener otros objetos, permitiendo agrupaciones y transformaciones jer\u00e1rquicas.</li> <li>Propiedades: Permite establecer propiedades globales como el fondo de la escena.</li> </ul> <p>Ejemplo de creaci\u00f3n de una escena:</p> <pre><code>const scene = new THREE.Scene();\n</code></pre>"},{"location":"Curso/2.%20Estructura%20B%C3%A1sica%20de%20una%20Escena%20en%20Three.js/#222-camara-threecamera","title":"2.2.2 C\u00e1mara (<code>THREE.Camera</code>)","text":"<p>La c\u00e1mara determina desde qu\u00e9 perspectiva se visualiza la escena. Existen diferentes tipos de c\u00e1maras en Three.js, pero las m\u00e1s comunes son:</p> <ul> <li>C\u00e1mara en Perspectiva (<code>THREE.PerspectiveCamera</code>): Simula la percepci\u00f3n humana con perspectiva, donde los objetos m\u00e1s lejanos parecen m\u00e1s peque\u00f1os.</li> <li>C\u00e1mara Ortogr\u00e1fica (<code>THREE.OrthographicCamera</code>): Muestra los objetos sin perspectiva, manteniendo las mismas dimensiones independientemente de la distancia.</li> </ul> <p>Para este tema, nos enfocaremos en la C\u00e1mara en Perspectiva.</p> <p>Par\u00e1metros clave de <code>PerspectiveCamera</code>:</p> <ul> <li>Campo de Visi\u00f3n (<code>fov</code>): \u00c1ngulo de visi\u00f3n en grados.</li> <li>Aspect Ratio (<code>aspect</code>): Proporci\u00f3n entre el ancho y alto de la pantalla.</li> <li>Plano cercano (<code>near</code>): Distancia m\u00ednima desde la c\u00e1mara donde los objetos comienzan a ser visibles.</li> <li>Plano lejano (<code>far</code>): Distancia m\u00e1xima desde la c\u00e1mara donde los objetos dejan de ser visibles.</li> </ul> <p>Ejemplo de creaci\u00f3n de una c\u00e1mara en perspectiva:</p> <pre><code>const camera = new THREE.PerspectiveCamera(\n    75, // Campo de visi\u00f3n en grados\n    window.innerWidth / window.innerHeight, // Aspect ratio\n    0.1, // Plano cercano\n    1000 // Plano lejano\n);\n</code></pre>"},{"location":"Curso/2.%20Estructura%20B%C3%A1sica%20de%20una%20Escena%20en%20Three.js/#223-renderizador-threerenderer","title":"2.2.3 Renderizador (<code>THREE.Renderer</code>)","text":"<p>El renderizador es responsable de dibujar la escena desde la perspectiva de la c\u00e1mara en el lienzo (<code>canvas</code>) HTML. El tipo m\u00e1s com\u00fan es el Renderizador WebGL (<code>THREE.WebGLRenderer</code>), que utiliza la API WebGL para renderizar gr\u00e1ficos 3D.</p> <p>Caracter\u00edsticas clave:</p> <ul> <li>Renderizaci\u00f3n en tiempo real: Actualiza la visualizaci\u00f3n continuamente para animaciones e interacciones.</li> <li>Configuraci\u00f3n de tama\u00f1o: Determina el tama\u00f1o del lienzo donde se renderiza la escena.</li> <li>Adjuntar al DOM: A\u00f1ade el lienzo al documento HTML para que sea visible en la p\u00e1gina.</li> </ul> <p>Ejemplo de creaci\u00f3n y configuraci\u00f3n del renderizador:</p> <pre><code>const renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight); // Configura el tama\u00f1o del lienzo\ndocument.body.appendChild(renderer.domElement); // A\u00f1ade el lienzo al DOM\n</code></pre>"},{"location":"Curso/2.%20Estructura%20B%C3%A1sica%20de%20una%20Escena%20en%20Three.js/#23-ciclo-de-renderizado","title":"2.3 Ciclo de Renderizado","text":"<p>El ciclo de renderizado es una funci\u00f3n que actualiza y dibuja la escena en cada frame, permitiendo animaciones y actualizaciones din\u00e1micas. Utiliza <code>requestAnimationFrame</code> para sincronizar la renderizaci\u00f3n con la tasa de refresco del navegador, optimizando el rendimiento.</p> <p>Pasos b\u00e1sicos del ciclo de renderizado:</p> <ol> <li>Actualizar objetos: Modificar las propiedades de los objetos (por ejemplo, rotaciones, posiciones).</li> <li>Renderizar la escena: Dibujar la escena desde la perspectiva de la c\u00e1mara.</li> <li>Solicitar el siguiente frame: Llamar nuevamente a la funci\u00f3n de animaci\u00f3n para el pr\u00f3ximo frame.</li> </ol> <p>Ejemplo de ciclo de renderizado:</p> <pre><code>function animate() {\n    requestAnimationFrame(animate); // Solicita el siguiente frame\n\n    // Actualiza objetos aqu\u00ed (por ejemplo, rotaciones)\n    cube.rotation.x += 0.01;\n    cube.rotation.y += 0.01;\n\n    // Renderiza la escena\n    renderer.render(scene, camera);\n}\n\nanimate(); // Inicia el ciclo de animaci\u00f3n\n</code></pre>"},{"location":"Curso/2.%20Estructura%20B%C3%A1sica%20de%20una%20Escena%20en%20Three.js/#24-manejo-del-redimensionamiento-de-la-ventana","title":"2.4 Manejo del Redimensionamiento de la Ventana","text":"<p>Es importante que la escena se adapte din\u00e1micamente al tama\u00f1o de la ventana del navegador para mantener la proporci\u00f3n y la calidad visual. Esto implica actualizar tanto el renderizador como la c\u00e1mara cuando la ventana cambia de tama\u00f1o.</p> <p>Implementaci\u00f3n del manejo de redimensionamiento:</p> <pre><code>window.addEventListener('resize', () =&gt; {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    // Actualiza el tama\u00f1o del renderizador\n    renderer.setSize(width, height);\n\n    // Actualiza la proporci\u00f3n de la c\u00e1mara\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n});\n</code></pre>"},{"location":"Curso/2.%20Estructura%20B%C3%A1sica%20de%20una%20Escena%20en%20Three.js/#25-ejemplo-completo-creacion-de-una-escena-basica","title":"2.5 Ejemplo Completo: Creaci\u00f3n de una Escena B\u00e1sica","text":"<p>A continuaci\u00f3n, se presenta un ejemplo completo que integra todos los conceptos mencionados anteriormente para crear una escena b\u00e1sica con un cubo giratorio.</p>"},{"location":"Curso/2.%20Estructura%20B%C3%A1sica%20de%20una%20Escena%20en%20Three.js/#251-estructura-de-carpetas","title":"2.5.1 Estructura de Carpetas","text":"<pre><code>mi-escena-basica-threejs/\n\u251c\u2500\u2500 index.html\n\u2514\u2500\u2500 js/\n    \u2514\u2500\u2500 three.min.js\n</code></pre>"},{"location":"Curso/2.%20Estructura%20B%C3%A1sica%20de%20una%20Escena%20en%20Three.js/#252-contenido-de-indexhtml","title":"2.5.2 Contenido de <code>index.html</code>","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Escena B\u00e1sica con Three.js&lt;/title&gt;\n    &lt;style&gt;\n        body { margin: 0; }\n        canvas { display: block; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- Enlace a Three.js --&gt;\n    &lt;script src=\"js/three.min.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n        // 1. Crear la escena\n        const scene = new THREE.Scene();\n\n        // 2. Crear la c\u00e1mara\n        const camera = new THREE.PerspectiveCamera(\n            75, // Campo de visi\u00f3n\n            window.innerWidth / window.innerHeight, // Aspect ratio\n            0.1, // Plano cercano\n            1000 // Plano lejano\n        );\n\n        // 3. Crear el renderizador\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        document.body.appendChild(renderer.domElement);\n\n        // 4. Crear una geometr\u00eda y material (un cubo)\n        const geometry = new THREE.BoxGeometry();\n        const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\n        const cube = new THREE.Mesh(geometry, material);\n        scene.add(cube); // A\u00f1adir el cubo a la escena\n\n        // 5. Posicionar la c\u00e1mara\n        camera.position.z = 5;\n\n        // 6. Funci\u00f3n de animaci\u00f3n\n        function animate() {\n            requestAnimationFrame(animate); // Solicita el siguiente frame\n\n            // Rotar el cubo\n            cube.rotation.x += 0.01;\n            cube.rotation.y += 0.01;\n\n            // Renderizar la escena\n            renderer.render(scene, camera);\n        }\n\n        animate(); // Inicia la animaci\u00f3n\n\n        // 7. Manejar el redimensionamiento de la ventana\n        window.addEventListener('resize', () =&gt; {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n\n            renderer.setSize(width, height);\n            camera.aspect = width / height;\n            camera.updateProjectionMatrix();\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"Curso/2.%20Estructura%20B%C3%A1sica%20de%20una%20Escena%20en%20Three.js/#253-ejecutar-el-proyecto","title":"2.5.3 Ejecutar el Proyecto","text":"<ol> <li>Estructura de carpetas:</li> <li>Crea una carpeta llamada <code>mi-escena-basica-threejs</code>.</li> <li>Dentro de ella, crea una subcarpeta <code>js</code> y descarga el archivo <code>three.min.js</code> desde el sitio oficial de Three.js.</li> <li> <p>Crea el archivo <code>index.html</code> con el contenido proporcionado anteriormente.</p> </li> <li> <p>Abrir el archivo en el navegador:</p> </li> <li>Abre el archivo <code>index.html</code> en tu navegador favorito (Chrome, Firefox, Edge, Safari).</li> <li>Deber\u00edas ver un cubo verde girando en el centro de la pantalla.</li> </ol>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/","title":"3. Geometr\u00edas y Materiales","text":""},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#31-introduccion-a-las-geometrias-y-materiales","title":"3.1 Introducci\u00f3n a las Geometr\u00edas y Materiales","text":"<p>En Three.js, las geometr\u00edas definen la forma de los objetos 3D, mientras que los materiales determinan c\u00f3mo se ven esas formas, incluyendo su color, textura, reflejos y otros efectos visuales. La combinaci\u00f3n de geometr\u00edas y materiales te permite crear una amplia variedad de objetos con diferentes apariencias y comportamientos en tu escena.</p>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#32-geometrias-basicas","title":"3.2 Geometr\u00edas B\u00e1sicas","text":"<p>Three.js ofrece una variedad de geometr\u00edas predefinidas que puedes utilizar para crear objetos 3D comunes. A continuaci\u00f3n, se describen algunas de las geometr\u00edas m\u00e1s utilizadas:</p>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#321-boxgeometry-caja","title":"3.2.1 BoxGeometry (Caja)","text":"<p>Crea una caja o cubo con dimensiones especificadas.</p> <p>Sintaxis:</p> <pre><code>const geometry = new THREE.BoxGeometry(ancho, alto, profundidad, segmentosAncho, segmentosAlto, segmentosProfundidad);\n</code></pre> <p>Ejemplo:</p> <pre><code>const geometry = new THREE.BoxGeometry(1, 1, 1); // Caja de 1 unidad en cada dimensi\u00f3n\n</code></pre>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#322-spheregeometry-esfera","title":"3.2.2 SphereGeometry (Esfera)","text":"<p>Crea una esfera con radio y segmentos especificados.</p> <p>Sintaxis:</p> <pre><code>const geometry = new THREE.SphereGeometry(radio, segmentosAncho, segmentosAlto);\n</code></pre> <p>Ejemplo:</p> <pre><code>const geometry = new THREE.SphereGeometry(1, 32, 32); // Esfera con radio 1 y 32 segmentos\n</code></pre>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#323-planegeometry-plano","title":"3.2.3 PlaneGeometry (Plano)","text":"<p>Crea un plano bidimensional.</p> <p>Sintaxis:</p> <pre><code>const geometry = new THREE.PlaneGeometry(ancho, alto, segmentosAncho, segmentosAlto);\n</code></pre> <p>Ejemplo:</p> <pre><code>const geometry = new THREE.PlaneGeometry(5, 5); // Plano de 5x5 unidades\n</code></pre>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#324-cylindergeometry-cilindro","title":"3.2.4 CylinderGeometry (Cilindro)","text":"<p>Crea un cilindro con radio superior e inferior, altura y segmentos especificados.</p> <p>Sintaxis:</p> <pre><code>const geometry = new THREE.CylinderGeometry(radioSuperior, radioInferior, altura, segmentosRadiales, segmentosAltura);\n</code></pre> <p>Ejemplo:</p> <pre><code>const geometry = new THREE.CylinderGeometry(1, 1, 2, 32); // Cilindro con radio 1, altura 2 y 32 segmentos radiales\n</code></pre>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#325-torusgeometry-toro","title":"3.2.5 TorusGeometry (Toro)","text":"<p>Crea un toro (donut) con radio mayor y menor, y segmentos especificados.</p> <p>Sintaxis:</p> <pre><code>const geometry = new THREE.TorusGeometry(radioMayor, radioMenor, segmentosRadiales, segmentosTubulares);\n</code></pre> <p>Ejemplo:</p> <pre><code>const geometry = new THREE.TorusGeometry(1, 0.4, 16, 100); // Toro con radio mayor 1, radio menor 0.4, 16 segmentos radiales y 100 tubulares\n</code></pre>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#326-geometrias-personalizadas","title":"3.2.6 Geometr\u00edas Personalizadas","text":"<p>Adem\u00e1s de las geometr\u00edas predefinidas, puedes crear geometr\u00edas personalizadas utilizando <code>THREE.BufferGeometry</code> y definiendo tus propios v\u00e9rtices y caras. Esto es \u00fatil para objetos m\u00e1s complejos o espec\u00edficos que no se pueden lograr con las geometr\u00edas b\u00e1sicas.</p> <p>Ejemplo de creaci\u00f3n de una geometr\u00eda personalizada:</p> <pre><code>const vertices = new Float32Array([\n    -1.0, -1.0,  1.0,\n     1.0, -1.0,  1.0,\n     1.0,  1.0,  1.0,\n    -1.0,  1.0,  1.0,\n    -1.0, -1.0, -1.0,\n     1.0, -1.0, -1.0,\n     1.0,  1.0, -1.0,\n    -1.0,  1.0, -1.0,\n]);\n\nconst indices = [\n    0, 1, 2,  0, 2, 3, // Front face\n    4, 5, 6,  4, 6, 7, // Back face\n    0, 4, 7,  0, 7, 3, // Left face\n    1, 5, 6,  1, 6, 2, // Right face\n    3, 2, 6,  3, 6, 7, // Top face\n    0, 1, 5,  0, 5, 4  // Bottom face\n];\n\nconst geometry = new THREE.BufferGeometry();\ngeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\ngeometry.setIndex(indices);\ngeometry.computeVertexNormals();\n</code></pre>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#33-materiales-basicos","title":"3.3 Materiales B\u00e1sicos","text":"<p>Three.js proporciona una variedad de materiales que puedes aplicar a tus geometr\u00edas para definir su apariencia. A continuaci\u00f3n, se describen algunos de los materiales m\u00e1s comunes:</p>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#331-meshbasicmaterial","title":"3.3.1 MeshBasicMaterial","text":"<p>Un material b\u00e1sico que no responde a la iluminaci\u00f3n. Es \u00fatil para objetos que deben mantenerse siempre visibles con un color constante.</p> <p>Sintaxis:</p> <pre><code>const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });\n</code></pre> <p>Propiedades comunes:</p> <ul> <li><code>color</code>: Color del material.</li> <li><code>wireframe</code>: Muestra el objeto como un wireframe (malla de l\u00edneas).</li> <li><code>map</code>: Aplicar una textura al material.</li> </ul>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#332-meshlambertmaterial","title":"3.3.2 MeshLambertMaterial","text":"<p>Un material que responde a la iluminaci\u00f3n de manera difusa. Es ideal para superficies mate sin reflejos brillantes.</p> <p>Sintaxis:</p> <pre><code>const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });\n</code></pre> <p>Propiedades comunes:</p> <ul> <li><code>color</code>: Color del material.</li> <li><code>emissive</code>: Color que el material emite (autoiluminaci\u00f3n).</li> <li><code>map</code>: Aplicar una textura al material.</li> </ul>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#333-meshphongmaterial","title":"3.3.3 MeshPhongMaterial","text":"<p>Un material que responde a la iluminaci\u00f3n con reflejos especulares, proporcionando un aspecto brillante y realista.</p> <p>Sintaxis:</p> <pre><code>const material = new THREE.MeshPhongMaterial({ color: 0x0000ff, shininess: 100 });\n</code></pre> <p>Propiedades comunes:</p> <ul> <li><code>color</code>: Color del material.</li> <li><code>shininess</code>: Controla el brillo de los reflejos especulares.</li> <li><code>specular</code>: Color de los reflejos especulares.</li> <li><code>map</code>: Aplicar una textura al material.</li> </ul>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#334-meshstandardmaterial","title":"3.3.4 MeshStandardMaterial","text":"<p>Un material f\u00edsico est\u00e1ndar que utiliza el modelo PBR (Physically Based Rendering) para lograr resultados altamente realistas.</p> <p>Sintaxis:</p> <pre><code>const material = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.5, roughness: 0.5 });\n</code></pre> <p>Propiedades comunes:</p> <ul> <li><code>color</code>: Color del material.</li> <li><code>metalness</code>: Define si el material es met\u00e1lico.</li> <li><code>roughness</code>: Define qu\u00e9 tan rugosa es la superficie.</li> <li><code>map</code>: Aplicar una textura al material.</li> <li><code>normalMap</code>: Aplicar un mapa de normales para simular detalles en la superficie.</li> <li><code>envMap</code>: Mapa de entorno para reflejos.</li> </ul>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#34-aplicacion-de-colores-y-texturas","title":"3.4 Aplicaci\u00f3n de Colores y Texturas","text":""},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#341-aplicar-color-solido","title":"3.4.1 Aplicar Color S\u00f3lido","text":"<p>Puedes definir un color s\u00f3lido para un material utilizando la propiedad <code>color</code>.</p> <p>Ejemplo:</p> <pre><code>const material = new THREE.MeshBasicMaterial({ color: 0xff5733 }); // Naranja rojizo\n</code></pre>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#342-aplicar-texturas","title":"3.4.2 Aplicar Texturas","text":"<p>Las texturas son im\u00e1genes que se aplican a las superficies de los objetos para agregar detalles visuales. Three.js utiliza el cargador de texturas (<code>THREE.TextureLoader</code>) para cargar y aplicar texturas a los materiales.</p> <p>Paso 1: Cargar la textura</p> <pre><code>const textureLoader = new THREE.TextureLoader();\nconst textura = textureLoader.load('ruta/a/tu/textura.jpg');\n</code></pre> <p>Paso 2: Aplicar la textura al material</p> <pre><code>const material = new THREE.MeshBasicMaterial({ map: textura });\n</code></pre> <p>Ejemplo Completo:</p> <pre><code>const textureLoader = new THREE.TextureLoader();\nconst textura = textureLoader.load('textures/brick_diffuse.jpg'); // Ruta a la textura\n\nconst material = new THREE.MeshBasicMaterial({ map: textura });\n\nconst geometry = new THREE.BoxGeometry(1, 1, 1);\nconst cubo = new THREE.Mesh(geometry, material);\nscene.add(cubo);\n</code></pre>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#343-uso-de-mapas-de-materiales","title":"3.4.3 Uso de Mapas de Materiales","text":"<p>Adem\u00e1s del mapa de color (<code>map</code>), existen otros tipos de mapas que puedes utilizar para mejorar la apariencia de tus materiales:</p> <ul> <li>Normal Map (<code>normalMap</code>): Simula detalles en la superficie sin aumentar el n\u00famero de pol\u00edgonos.</li> </ul> <p>Ejemplo:</p> <p><code>javascript   const normalMap = textureLoader.load('textures/brick_normal.jpg');   const material = new THREE.MeshStandardMaterial({ map: textura, normalMap: normalMap });</code></p> <ul> <li> <p>Specular Map (<code>specularMap</code>): Define las \u00e1reas que reflejan la luz de manera especular.</p> </li> <li> <p>Emissive Map (<code>emissiveMap</code>): Define las \u00e1reas que emiten luz.</p> </li> <li> <p>Displacement Map (<code>displacementMap</code>): Desplaza los v\u00e9rtices de la geometr\u00eda seg\u00fan la textura, creando relieves.</p> </li> </ul>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#35-ejemplo-completo-cubo-con-textura","title":"3.5 Ejemplo Completo: Cubo con Textura","text":"<p>A continuaci\u00f3n, se presenta un ejemplo completo que crea un cubo y le aplica una textura de ladrillo, utilizando un material que responde a la iluminaci\u00f3n para obtener un efecto m\u00e1s realista.</p>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#351-estructura-de-carpetas","title":"3.5.1 Estructura de Carpetas","text":"<pre><code>mi-escena-textura-threejs/\n\u251c\u2500\u2500 index.html\n\u251c\u2500\u2500 js/\n\u2502   \u2514\u2500\u2500 three.min.js\n\u251c\u2500\u2500 textures/\n\u2502   \u251c\u2500\u2500 brick_diffuse.jpg\n\u2502   \u2514\u2500\u2500 brick_normal.jpg\n</code></pre>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#352-contenido-de-indexhtml","title":"3.5.2 Contenido de <code>index.html</code>","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Cubo con Textura en Three.js&lt;/title&gt;\n    &lt;style&gt;\n        body { margin: 0; }\n        canvas { display: block; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- Enlace a Three.js --&gt;\n    &lt;script src=\"js/three.min.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n        // 1. Crear la escena\n        const scene = new THREE.Scene();\n\n        // 2. Crear la c\u00e1mara\n        const camera = new THREE.PerspectiveCamera(\n            75,\n            window.innerWidth / window.innerHeight,\n            0.1,\n            1000\n        );\n\n        // 3. Crear el renderizador\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.shadowMap.enabled = true; // Habilitar sombras\n        document.body.appendChild(renderer.domElement);\n\n        // 4. A\u00f1adir una luz ambiental\n        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Luz suave\n        scene.add(ambientLight);\n\n        // 5. A\u00f1adir una luz direccional\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n        directionalLight.position.set(5, 10, 7.5);\n        directionalLight.castShadow = true; // Habilitar sombras para esta luz\n        scene.add(directionalLight);\n\n        // 6. Cargar texturas\n        const textureLoader = new THREE.TextureLoader();\n        const texturaDifusa = textureLoader.load('textures/brick_diffuse.jpg'); // Textura difusa\n        const texturaNormal = textureLoader.load('textures/brick_normal.jpg'); // Mapa de normales\n\n        // 7. Crear el material\n        const material = new THREE.MeshStandardMaterial({\n            map: texturaDifusa,\n            normalMap: texturaNormal\n        });\n\n        // 8. Crear la geometr\u00eda y la malla\n        const geometry = new THREE.BoxGeometry(2, 2, 2);\n        const cubo = new THREE.Mesh(geometry, material);\n        cubo.castShadow = true; // El cubo puede proyectar sombras\n        cubo.receiveShadow = true; // El cubo puede recibir sombras\n        scene.add(cubo);\n\n        // 9. Crear el suelo\n        const sueloGeometry = new THREE.PlaneGeometry(10, 10);\n        const sueloMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });\n        const suelo = new THREE.Mesh(sueloGeometry, sueloMaterial);\n        suelo.rotation.x = -Math.PI / 2; // Rotar para que quede horizontal\n        suelo.position.y = -2; // Posicionar debajo del cubo\n        suelo.receiveShadow = true; // El suelo puede recibir sombras\n        scene.add(suelo);\n\n        // 10. Posicionar la c\u00e1mara\n        camera.position.set(5, 5, 5);\n        camera.lookAt(cubo.position);\n\n        // 11. Funci\u00f3n de animaci\u00f3n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            // Rotar el cubo\n            cubo.rotation.x += 0.005;\n            cubo.rotation.y += 0.005;\n\n            // Renderizar la escena\n            renderer.render(scene, camera);\n        }\n\n        animate();\n\n        // 12. Manejar el redimensionamiento de la ventana\n        window.addEventListener('resize', () =&gt; {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n\n            renderer.setSize(width, height);\n            camera.aspect = width / height;\n            camera.updateProjectionMatrix();\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#353-explicacion-del-codigo","title":"3.5.3 Explicaci\u00f3n del C\u00f3digo","text":"<ol> <li>Escena y C\u00e1mara:</li> <li>Se crea una escena y una c\u00e1mara en perspectiva.</li> <li> <p>La c\u00e1mara est\u00e1 posicionada en (5, 5, 5) y mira hacia el cubo.</p> </li> <li> <p>Renderizador:</p> </li> <li> <p>Se configura el renderizador para ocupar toda la ventana y se habilitan las sombras.</p> </li> <li> <p>Iluminaci\u00f3n:</p> </li> <li>Luz Ambiental (<code>AmbientLight</code>): Proporciona una iluminaci\u00f3n suave y uniforme en toda la escena.</li> <li> <p>Luz Direccional (<code>DirectionalLight</code>): Simula una fuente de luz distante, como el sol, y est\u00e1 configurada para proyectar sombras.</p> </li> <li> <p>Texturas:</p> </li> <li> <p>Se cargan una textura difusa (<code>brick_diffuse.jpg</code>) y un mapa de normales (<code>brick_normal.jpg</code>) para darle detalles adicionales al material.</p> </li> <li> <p>Material y Malla:</p> </li> <li>Se crea un <code>MeshStandardMaterial</code> que utiliza las texturas cargadas.</li> <li>Se aplica este material a una geometr\u00eda de caja (<code>BoxGeometry</code>) para crear la malla del cubo.</li> <li> <p>El cubo est\u00e1 configurado para proyectar y recibir sombras.</p> </li> <li> <p>Suelo:</p> </li> <li>Se crea un plano que act\u00faa como suelo, con un color gris.</li> <li>El suelo est\u00e1 rotado para quedar horizontal y posicionado debajo del cubo.</li> <li> <p>Est\u00e1 configurado para recibir sombras.</p> </li> <li> <p>Animaci\u00f3n:</p> </li> <li> <p>Se define una funci\u00f3n <code>animate</code> que rota el cubo ligeramente en cada frame y renderiza la escena.</p> </li> <li> <p>Redimensionamiento:</p> </li> <li>Se a\u00f1ade un evento que actualiza el tama\u00f1o del renderizador y la c\u00e1mara cuando la ventana del navegador cambia de tama\u00f1o.</li> </ol>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#354-recursos-de-texturas","title":"3.5.4 Recursos de Texturas","text":"<p>Para este ejemplo, necesitar\u00e1s dos texturas:</p> <ol> <li>brick_diffuse.jpg: Una imagen que representa el color base de los ladrillos.</li> <li>brick_normal.jpg: Una imagen en escala de grises que representa las normales para simular detalles en la superficie.</li> </ol> <p>Puedes encontrar texturas gratuitas en sitios como CC0 Textures o Textures.com.</p>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#36-manipulacion-de-materiales","title":"3.6 Manipulaci\u00f3n de Materiales","text":""},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#361-cambiar-propiedades-de-materiales-en-tiempo-de-ejecucion","title":"3.6.1 Cambiar Propiedades de Materiales en Tiempo de Ejecuci\u00f3n","text":"<p>Puedes cambiar las propiedades de un material en tiempo real para crear efectos din\u00e1micos.</p> <p>Ejemplo: Cambiar el color de un material al hacer clic</p> <pre><code>cubo.material.color.set(0xff0000); // Cambia el color del cubo a rojo\n</code></pre>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#362-transparencia","title":"3.6.2 Transparencia","text":"<p>Puedes hacer que un material sea transparente ajustando la propiedad <code>transparent</code> y <code>opacity</code>.</p> <p>Ejemplo: Material Transparente</p> <pre><code>const materialTransparente = new THREE.MeshBasicMaterial({\n    color: 0x00ff00,\n    transparent: true,\n    opacity: 0.5\n});\n</code></pre>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#363-wireframe","title":"3.6.3 Wireframe","text":"<p>Puedes visualizar la estructura de una geometr\u00eda como un wireframe (malla de l\u00edneas) estableciendo la propiedad <code>wireframe</code>.</p> <p>Ejemplo: Material Wireframe</p> <pre><code>const materialWireframe = new THREE.MeshBasicMaterial({\n    color: 0xffffff,\n    wireframe: true\n});\n</code></pre>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#37-geometrias-compuestas-y-agrupacion-de-objetos","title":"3.7 Geometr\u00edas Compuestas y Agrupaci\u00f3n de Objetos","text":"<p>Three.js permite crear geometr\u00edas m\u00e1s complejas combinando m\u00faltiples geometr\u00edas b\u00e1sicas o agrupando objetos.</p>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#371-union-de-geometrias","title":"3.7.1 Uni\u00f3n de Geometr\u00edas","text":"<p>Puedes combinar varias geometr\u00edas en una sola utilizando <code>THREE.Group</code> o <code>THREE.Object3D</code>.</p> <p>Ejemplo: Crear una figura compuesta de dos cajas</p> <pre><code>const grupo = new THREE.Group();\n\nconst geometria1 = new THREE.BoxGeometry(1, 1, 1);\nconst material1 = new THREE.MeshBasicMaterial({ color: 0xff0000 });\nconst cubo1 = new THREE.Mesh(geometria1, material1);\ncubo1.position.set(-1.5, 0, 0);\n\nconst geometria2 = new THREE.BoxGeometry(1, 1, 1);\nconst material2 = new THREE.MeshBasicMaterial({ color: 0x0000ff });\nconst cubo2 = new THREE.Mesh(geometria2, material2);\ncubo2.position.set(1.5, 0, 0);\n\ngrupo.add(cubo1);\ngrupo.add(cubo2);\n\nscene.add(grupo);\n</code></pre>"},{"location":"Curso/3.%20Geometr%C3%ADas%20y%20Materiales/#372-uso-de-threeinstancedmesh","title":"3.7.2 Uso de <code>THREE.InstancedMesh</code>","text":"<p>Para optimizar la renderizaci\u00f3n de m\u00faltiples instancias de la misma geometr\u00eda y material, puedes usar <code>THREE.InstancedMesh</code>.</p> <p>Ejemplo: Crear 100 esferas instanciadas</p> <pre><code>const cantidad = 100;\nconst geometria = new THREE.SphereGeometry(0.5, 16, 16);\nconst material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });\n\nconst instancias = new THREE.InstancedMesh(geometria, material, cantidad);\n\nfor (let i = 0; i &lt; cantidad; i++) {\n    const matriz = new THREE.Matrix4();\n    matriz.setPosition(\n        Math.random() * 20 - 10,\n        Math.random() * 20 - 10,\n        Math.random() * 20 - 10\n    );\n    instancias.setMatrixAt(i, matriz);\n}\n\nscene.add(instancias);\n</code></pre>"},{"location":"Curso/4.%20Luces%20en%20Three.js/","title":"4. Luces en Three.js","text":""},{"location":"Curso/4.%20Luces%20en%20Three.js/#41-introduccion-a-las-luces","title":"4.1 Introducci\u00f3n a las Luces","text":"<p>La iluminaci\u00f3n es un componente crucial en cualquier entorno 3D, ya que determina c\u00f3mo se ven los objetos, sus colores, sombras y texturas. En Three.js, las luces simulan diferentes fuentes de luz presentes en el mundo real, permitiendo crear ambientes realistas o estilizados seg\u00fan tus necesidades.</p>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#42-tipos-de-luces-en-threejs","title":"4.2 Tipos de Luces en Three.js","text":""},{"location":"Curso/4.%20Luces%20en%20Three.js/#421-threeambientlight","title":"4.2.1 <code>THREE.AmbientLight</code>","text":"<ul> <li>Descripci\u00f3n: Proporciona una iluminaci\u00f3n uniforme en toda la escena sin direcci\u00f3n espec\u00edfica. No crea sombras y afecta a todos los objetos de manera igualitaria.</li> <li>Uso com\u00fan: Simular luz ambiental general, como la luz difusa que no proviene de una fuente espec\u00edfica.</li> </ul> <p>Sintaxis:</p> <pre><code>const ambientLight = new THREE.AmbientLight(color, intensidad);\n</code></pre> <p>Ejemplo:</p> <pre><code>const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Luz blanca con 50% de intensidad\nscene.add(ambientLight);\n</code></pre>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#422-threedirectionallight","title":"4.2.2 <code>THREE.DirectionalLight</code>","text":"<ul> <li>Descripci\u00f3n: Simula una fuente de luz distante que emite luz en una direcci\u00f3n espec\u00edfica, similar al sol. Puede proyectar sombras.</li> <li>Uso com\u00fan: Iluminaci\u00f3n principal de la escena, proporcionando sombras y profundidad.</li> </ul> <p>Sintaxis:</p> <pre><code>const directionalLight = new THREE.DirectionalLight(color, intensidad);\n</code></pre> <p>Ejemplo:</p> <pre><code>const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\ndirectionalLight.position.set(5, 10, 7.5); // Posici\u00f3n de la luz\nscene.add(directionalLight);\n</code></pre>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#423-threepointlight","title":"4.2.3 <code>THREE.PointLight</code>","text":"<ul> <li>Descripci\u00f3n: Emite luz en todas las direcciones desde un punto espec\u00edfico, similar a una bombilla. Puede proyectar sombras.</li> <li>Uso com\u00fan: Simular fuentes de luz localizadas, como l\u00e1mparas o luces ambientales.</li> </ul> <p>Sintaxis:</p> <pre><code>const pointLight = new THREE.PointLight(color, intensidad, distancia, atenuaci\u00f3n);\n</code></pre> <p>Ejemplo:</p> <pre><code>const pointLight = new THREE.PointLight(0xffffff, 1, 100);\npointLight.position.set(0, 10, 0);\nscene.add(pointLight);\n</code></pre>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#424-threespotlight","title":"4.2.4 <code>THREE.SpotLight</code>","text":"<ul> <li>Descripci\u00f3n: Emite luz en un cono desde una posici\u00f3n espec\u00edfica, con \u00e1ngulo y penumbra ajustables. Puede proyectar sombras.</li> <li>Uso com\u00fan: Simular focos de luz, como l\u00e1mparas de escenario o linternas.</li> </ul> <p>Sintaxis:</p> <pre><code>const spotLight = new THREE.SpotLight(color, intensidad, distancia, \u00e1ngulo, penumbra, decaimiento);\n</code></pre> <p>Ejemplo:</p> <pre><code>const spotLight = new THREE.SpotLight(0xffffff, 1);\nspotLight.position.set(10, 20, 10);\nspotLight.angle = Math.PI / 6; // \u00c1ngulo del cono de luz\nspotLight.penumbra = 0.1; // Transici\u00f3n suave en los bordes\nscene.add(spotLight);\n</code></pre>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#425-threehemispherelight","title":"4.2.5 <code>THREE.HemisphereLight</code>","text":"<ul> <li>Descripci\u00f3n: Simula la luz ambiental proveniente del cielo y del suelo, proporcionando una iluminaci\u00f3n suave y difusa sin direcci\u00f3n espec\u00edfica.</li> <li>Uso com\u00fan: Crear efectos de iluminaci\u00f3n natural, como la luz del d\u00eda.</li> </ul> <p>Sintaxis:</p> <pre><code>const hemisphereLight = new THREE.HemisphereLight(skyColor, groundColor, intensidad);\n</code></pre> <p>Ejemplo:</p> <pre><code>const hemisphereLight = new THREE.HemisphereLight(0xaaaaaa, 0x444444, 1);\nhemisphereLight.position.set(0, 20, 0);\nscene.add(hemisphereLight);\n</code></pre>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#426-threerectarealight","title":"4.2.6 <code>THREE.RectAreaLight</code>","text":"<ul> <li>Descripci\u00f3n: Emite luz desde una superficie rectangular, proporcionando una iluminaci\u00f3n suave y realista. Requiere el uso de materiales espec\u00edficos (<code>MeshStandardMaterial</code> o <code>MeshPhysicalMaterial</code>).</li> <li>Uso com\u00fan: Simular luces de ventana o paneles de luz.</li> </ul> <p>Sintaxis:</p> <pre><code>const rectAreaLight = new THREE.RectAreaLight(color, intensidad, ancho, alto);\n</code></pre> <p>Ejemplo:</p> <pre><code>const rectAreaLight = new THREE.RectAreaLight(0xffffff, 1, 4, 2);\nrectAreaLight.position.set(0, 10, 0);\nrectAreaLight.lookAt(0, 0, 0); // Orientar la luz hacia el centro de la escena\nscene.add(rectAreaLight);\n</code></pre> <p>Nota: <code>RectAreaLight</code> no soporta sombras en Three.js en la versi\u00f3n actual. Para utilizarlo correctamente, aseg\u00farate de que los materiales de los objetos sean compatibles.</p>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#43-anadir-luces-a-la-escena","title":"4.3 A\u00f1adir Luces a la Escena","text":"<p>Agregar luces a una escena en Three.js es sencillo. A continuaci\u00f3n, se muestra c\u00f3mo integrar diferentes tipos de luces en una escena b\u00e1sica.</p> <p>Ejemplo Completo: Integraci\u00f3n de Varias Luces</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Luces en Three.js&lt;/title&gt;\n    &lt;style&gt;\n        body { margin: 0; }\n        canvas { display: block; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- Enlace a Three.js --&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n        // 1. Crear la escena\n        const scene = new THREE.Scene();\n\n        // 2. Crear la c\u00e1mara\n        const camera = new THREE.PerspectiveCamera(\n            75,\n            window.innerWidth / window.innerHeight,\n            0.1,\n            1000\n        );\n        camera.position.set(0, 5, 10);\n        camera.lookAt(0, 0, 0);\n\n        // 3. Crear el renderizador\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.shadowMap.enabled = true; // Habilitar sombras\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Tipo de sombras\n        document.body.appendChild(renderer.domElement);\n\n        // 4. A\u00f1adir AmbientLight\n        const ambientLight = new THREE.AmbientLight(0x404040, 1); // Luz ambiental suave\n        scene.add(ambientLight);\n\n        // 5. A\u00f1adir DirectionalLight\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n        directionalLight.position.set(5, 10, 7.5);\n        directionalLight.castShadow = true; // La luz proyecta sombras\n        // Configuraci\u00f3n de sombras\n        directionalLight.shadow.mapSize.width = 1024;\n        directionalLight.shadow.mapSize.height = 1024;\n        directionalLight.shadow.camera.near = 0.5;\n        directionalLight.shadow.camera.far = 50;\n        scene.add(directionalLight);\n\n        // 6. A\u00f1adir PointLight\n        const pointLight = new THREE.PointLight(0xff0000, 1, 100);\n        pointLight.position.set(-5, 5, -5);\n        pointLight.castShadow = true;\n        scene.add(pointLight);\n\n        // 7. Crear un objeto para iluminar\n        const geometry = new THREE.BoxGeometry(2, 2, 2);\n        const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });\n        const cube = new THREE.Mesh(geometry, material);\n        cube.castShadow = true; // El cubo proyecta sombras\n        cube.receiveShadow = true; // El cubo recibe sombras\n        scene.add(cube);\n\n        // 8. Crear el suelo\n        const sueloGeometry = new THREE.PlaneGeometry(20, 20);\n        const sueloMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });\n        const suelo = new THREE.Mesh(sueloGeometry, sueloMaterial);\n        suelo.rotation.x = -Math.PI / 2; // Rotar para que quede horizontal\n        suelo.position.y = -1;\n        suelo.receiveShadow = true; // El suelo recibe sombras\n        scene.add(suelo);\n\n        // 9. Funci\u00f3n de animaci\u00f3n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            // Rotar el cubo\n            cube.rotation.x += 0.01;\n            cube.rotation.y += 0.01;\n\n            // Renderizar la escena\n            renderer.render(scene, camera);\n        }\n\n        animate();\n\n        // 10. Manejar el redimensionamiento de la ventana\n        window.addEventListener('resize', () =&gt; {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n\n            renderer.setSize(width, height);\n            camera.aspect = width / height;\n            camera.updateProjectionMatrix();\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Explicaci\u00f3n del C\u00f3digo:</p> <ol> <li>Escena y C\u00e1mara:</li> <li> <p>Se crea una escena y una c\u00e1mara en perspectiva posicionada en <code>(0, 5, 10)</code>, mirando hacia el centro de la escena.</p> </li> <li> <p>Renderizador:</p> </li> <li> <p>Se configura el renderizador para ocupar toda la ventana, se habilitan las sombras y se establece el tipo de sombra (<code>PCFSoftShadowMap</code>) para obtener sombras m\u00e1s suaves.</p> </li> <li> <p>Luces:</p> </li> <li>AmbientLight: Proporciona una iluminaci\u00f3n base suave en toda la escena.</li> <li>DirectionalLight: Simula una fuente de luz distante como el sol, proyectando sombras. Se configuran sus propiedades de sombra para mejorar la calidad.</li> <li> <p>PointLight: A\u00f1ade una fuente de luz localizada en una posici\u00f3n espec\u00edfica, con color rojo y capaz de proyectar sombras.</p> </li> <li> <p>Objetos:</p> </li> <li>Cubo: Un objeto con <code>MeshStandardMaterial</code> que responde a la iluminaci\u00f3n. Est\u00e1 configurado para proyectar y recibir sombras.</li> <li> <p>Suelo: Un plano que act\u00faa como suelo, recibiendo sombras proyectadas por el cubo y las luces.</p> </li> <li> <p>Animaci\u00f3n:</p> </li> <li> <p>Se define una funci\u00f3n <code>animate</code> que rota el cubo en cada frame y renderiza la escena.</p> </li> <li> <p>Redimensionamiento:</p> </li> <li>Se a\u00f1ade un evento que actualiza el tama\u00f1o del renderizador y la c\u00e1mara cuando la ventana cambia de tama\u00f1o.</li> </ol>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#44-configuracion-de-sombras","title":"4.4 Configuraci\u00f3n de Sombras","text":"<p>Las sombras a\u00f1aden realismo a las escenas 3D al simular la obstrucci\u00f3n de la luz por objetos. Para gestionar las sombras en Three.js, se deben seguir varios pasos:</p>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#441-habilitar-sombras-en-el-renderizador","title":"4.4.1 Habilitar Sombras en el Renderizador","text":"<p>Antes de poder utilizar sombras, es necesario habilitarlas en el renderizador.</p> <p>Ejemplo:</p> <pre><code>const renderer = new THREE.WebGLRenderer({ antialias: true });\nrenderer.shadowMap.enabled = true; // Habilitar sombras\nrenderer.shadowMap.type = THREE.PCFSoftShadowMap; // Tipo de sombra (opcional)\n</code></pre>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#442-configurar-luces-para-proyectar-sombras","title":"4.4.2 Configurar Luces para Proyectar Sombras","text":"<p>No todas las luces pueden proyectar sombras. Las luces que pueden hacerlo son:</p> <ul> <li><code>DirectionalLight</code></li> <li><code>SpotLight</code></li> <li><code>PointLight</code> (en versiones m\u00e1s recientes de Three.js)</li> </ul> <p>Para habilitar sombras en una luz, se debe establecer la propiedad <code>castShadow</code> en <code>true</code> y ajustar las propiedades de la sombra para mejorar la calidad.</p> <p>Ejemplo:</p> <pre><code>const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\ndirectionalLight.position.set(5, 10, 7.5);\ndirectionalLight.castShadow = true; // La luz proyecta sombras\n\n// Configurar la sombra\ndirectionalLight.shadow.mapSize.width = 1024;\ndirectionalLight.shadow.mapSize.height = 1024;\ndirectionalLight.shadow.camera.near = 0.5;\ndirectionalLight.shadow.camera.far = 50;\n\nscene.add(directionalLight);\n</code></pre>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#443-configurar-objetos-para-proyectar-y-recibir-sombras","title":"4.4.3 Configurar Objetos para Proyectar y Recibir Sombras","text":"<p>Para que los objetos interact\u00faen con las sombras, deben configurarse adecuadamente.</p> <ul> <li>Proyectar sombras (<code>castShadow</code>): Determina si el objeto puede proyectar sombras sobre otros objetos.</li> <li>Recibir sombras (<code>receiveShadow</code>): Determina si el objeto puede recibir sombras de otros objetos.</li> </ul> <p>Ejemplo:</p> <pre><code>// Objeto que proyecta y recibe sombras\nconst cube = new THREE.Mesh(geometry, material);\ncube.castShadow = true; // El cubo proyecta sombras\ncube.receiveShadow = true; // El cubo puede recibir sombras\nscene.add(cube);\n\n// Objeto que solo recibe sombras\nconst floor = new THREE.Mesh(floorGeometry, floorMaterial);\nfloor.receiveShadow = true; // El suelo puede recibir sombras\nscene.add(floor);\n</code></pre>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#444-ajustar-la-calidad-de-las-sombras","title":"4.4.4 Ajustar la Calidad de las Sombras","text":"<p>Para mejorar la calidad de las sombras, puedes ajustar varias propiedades de la luz y de la sombra.</p> <p>Propiedades Clave:</p> <ul> <li><code>shadow.mapSize</code>: Define la resoluci\u00f3n del mapa de sombras. Valores m\u00e1s altos mejoran la calidad pero consumen m\u00e1s recursos.</li> <li><code>shadow.camera</code>: Define el \u00e1rea de visi\u00f3n de la c\u00e1mara de sombras. Ajustar <code>near</code>, <code>far</code>, <code>left</code>, <code>right</code>, <code>top</code>, <code>bottom</code> para optimizar.</li> <li><code>shadow.bias</code>: Ayuda a prevenir artefactos como el \"shadow acne\" ajustando un sesgo en las sombras.</li> </ul> <p>Ejemplo:</p> <pre><code>directionalLight.shadow.mapSize.width = 2048;\ndirectionalLight.shadow.mapSize.height = 2048;\n\ndirectionalLight.shadow.camera.left = -10;\ndirectionalLight.shadow.camera.right = 10;\ndirectionalLight.shadow.camera.top = 10;\ndirectionalLight.shadow.camera.bottom = -10;\n\ndirectionalLight.shadow.bias = -0.001;\n</code></pre>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#45-efectos-de-las-luces-en-materiales","title":"4.5 Efectos de las Luces en Materiales","text":"<p>Los materiales en Three.js interact\u00faan de manera diferente con las luces seg\u00fan su tipo y propiedades. A continuaci\u00f3n, se explica c\u00f3mo las luces afectan a algunos materiales comunes:</p>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#451-meshbasicmaterial","title":"4.5.1 <code>MeshBasicMaterial</code>","text":"<ul> <li>Descripci\u00f3n: Material b\u00e1sico que no responde a la iluminaci\u00f3n. Siempre muestra el color o textura tal como est\u00e1 definido.</li> <li>Interacci\u00f3n con luces: Ninguna. Las luces no afectan este material.</li> </ul> <p>Uso:</p> <pre><code>const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });\n</code></pre>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#452-meshlambertmaterial","title":"4.5.2 <code>MeshLambertMaterial</code>","text":"<ul> <li>Descripci\u00f3n: Material que responde a la iluminaci\u00f3n difusa, simulando superficies mate.</li> <li>Interacci\u00f3n con luces: Reacciona a <code>AmbientLight</code> y otras luces que emiten luz difusa.</li> </ul> <p>Uso:</p> <pre><code>const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });\n</code></pre>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#453-meshphongmaterial","title":"4.5.3 <code>MeshPhongMaterial</code>","text":"<ul> <li>Descripci\u00f3n: Material que responde a la iluminaci\u00f3n difusa y especular, simulando superficies brillantes.</li> <li>Interacci\u00f3n con luces: Reacciona a todas las fuentes de luz y permite la configuraci\u00f3n de reflejos especulares.</li> </ul> <p>Uso:</p> <pre><code>const material = new THREE.MeshPhongMaterial({ color: 0x0000ff, shininess: 100 });\n</code></pre>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#454-meshstandardmaterial","title":"4.5.4 <code>MeshStandardMaterial</code>","text":"<ul> <li>Descripci\u00f3n: Material basado en PBR (Physically Based Rendering) que proporciona un realismo superior al simular propiedades f\u00edsicas de los materiales.</li> <li>Interacci\u00f3n con luces: Reacciona a todas las fuentes de luz, permitiendo configuraciones detalladas como metalicidad y rugosidad.</li> </ul> <p>Uso:</p> <pre><code>const material = new THREE.MeshStandardMaterial({\n    color: 0xffffff,\n    metalness: 0.5,\n    roughness: 0.5\n});\n</code></pre>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#46-ejemplos-practicos","title":"4.6 Ejemplos Pr\u00e1cticos","text":"<p>A continuaci\u00f3n, se presentan dos ejemplos que ilustran el uso de diferentes tipos de luces y c\u00f3mo afectan a los objetos en la escena.</p>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#461-ejemplo-1-escena-con-ambientlight-y-directionallight","title":"4.6.1 Ejemplo 1: Escena con <code>AmbientLight</code> y <code>DirectionalLight</code>","text":"<p>Este ejemplo muestra c\u00f3mo combinar una luz ambiental con una luz direccional para iluminar una escena b\u00e1sica con un cubo y un suelo.</p> <p>Estructura de Carpetas:</p> <pre><code>mi-escena-luces-threejs/\n\u251c\u2500\u2500 index.html\n\u2514\u2500\u2500 textures/\n    \u2514\u2500\u2500 brick_diffuse.jpg\n</code></pre> <p>Contenido de <code>index.html</code>:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Luces B\u00e1sicas en Three.js&lt;/title&gt;\n    &lt;style&gt;\n        body { margin: 0; }\n        canvas { display: block; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- Enlace a Three.js --&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n        // 1. Crear la escena\n        const scene = new THREE.Scene();\n\n        // 2. Crear la c\u00e1mara\n        const camera = new THREE.PerspectiveCamera(\n            75,\n            window.innerWidth / window.innerHeight,\n            0.1,\n            1000\n        );\n        camera.position.set(0, 5, 10);\n        camera.lookAt(0, 0, 0);\n\n        // 3. Crear el renderizador\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.shadowMap.enabled = true; // Habilitar sombras\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        document.body.appendChild(renderer.domElement);\n\n        // 4. A\u00f1adir AmbientLight\n        const ambientLight = new THREE.AmbientLight(0x404040, 1); // Luz ambiental suave\n        scene.add(ambientLight);\n\n        // 5. A\u00f1adir DirectionalLight\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n        directionalLight.position.set(5, 10, 7.5);\n        directionalLight.castShadow = true; // La luz proyecta sombras\n\n        // Configuraci\u00f3n de la sombra\n        directionalLight.shadow.mapSize.width = 1024;\n        directionalLight.shadow.mapSize.height = 1024;\n        directionalLight.shadow.camera.near = 0.5;\n        directionalLight.shadow.camera.far = 50;\n        directionalLight.shadow.camera.left = -10;\n        directionalLight.shadow.camera.right = 10;\n        directionalLight.shadow.camera.top = 10;\n        directionalLight.shadow.camera.bottom = -10;\n\n        scene.add(directionalLight);\n\n        // 6. Crear el cubo\n        const geometry = new THREE.BoxGeometry(2, 2, 2);\n        const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });\n        const cube = new THREE.Mesh(geometry, material);\n        cube.castShadow = true; // El cubo proyecta sombras\n        cube.receiveShadow = true; // El cubo puede recibir sombras\n        scene.add(cube);\n\n        // 7. Crear el suelo\n        const floorGeometry = new THREE.PlaneGeometry(20, 20);\n        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });\n        const floor = new THREE.Mesh(floorGeometry, floorMaterial);\n        floor.rotation.x = -Math.PI / 2; // Rotar para que quede horizontal\n        floor.position.y = -1;\n        floor.receiveShadow = true; // El suelo recibe sombras\n        scene.add(floor);\n\n        // 8. Funci\u00f3n de animaci\u00f3n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            // Rotar el cubo\n            cube.rotation.x += 0.01;\n            cube.rotation.y += 0.01;\n\n            // Renderizar la escena\n            renderer.render(scene, camera);\n        }\n\n        animate();\n\n        // 9. Manejar el redimensionamiento de la ventana\n        window.addEventListener('resize', () =&gt; {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n\n            renderer.setSize(width, height);\n            camera.aspect = width / height;\n            camera.updateProjectionMatrix();\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Resultado Esperado:</p> <p>Una escena con un cubo verde giratorio iluminado por una luz ambiental suave y una luz direccional que proyecta sombras sobre un suelo gris. La combinaci\u00f3n de luces crea una apariencia equilibrada con profundidad gracias a las sombras.</p>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#462-ejemplo-2-uso-de-spotlight-con-sombras","title":"4.6.2 Ejemplo 2: Uso de <code>SpotLight</code> con Sombras","text":"<p>Este ejemplo demuestra c\u00f3mo utilizar una <code>SpotLight</code> para iluminar un objeto espec\u00edfico y crear sombras din\u00e1micas.</p> <p>Estructura de Carpetas:</p> <pre><code>mi-escena-spotlight-threejs/\n\u251c\u2500\u2500 index.html\n\u2514\u2500\u2500 textures/\n    \u2514\u2500\u2500 floor_texture.jpg\n</code></pre> <p>Contenido de <code>index.html</code>:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;SpotLight en Three.js&lt;/title&gt;\n    &lt;style&gt;\n        body { margin: 0; }\n        canvas { display: block; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- Enlace a Three.js --&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n        // 1. Crear la escena\n        const scene = new THREE.Scene();\n\n        // 2. Crear la c\u00e1mara\n        const camera = new THREE.PerspectiveCamera(\n            75,\n            window.innerWidth / window.innerHeight,\n            0.1,\n            1000\n        );\n        camera.position.set(0, 5, 15);\n        camera.lookAt(0, 0, 0);\n\n        // 3. Crear el renderizador\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.shadowMap.enabled = true; // Habilitar sombras\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        document.body.appendChild(renderer.domElement);\n\n        // 4. A\u00f1adir SpotLight\n        const spotLight = new THREE.SpotLight(0xffffff, 1);\n        spotLight.position.set(0, 10, 10);\n        spotLight.angle = Math.PI / 6;\n        spotLight.penumbra = 0.1;\n        spotLight.decay = 2;\n        spotLight.distance = 50;\n        spotLight.castShadow = true; // La luz proyecta sombras\n\n        // Configuraci\u00f3n de la sombra\n        spotLight.shadow.mapSize.width = 1024;\n        spotLight.shadow.mapSize.height = 1024;\n        spotLight.shadow.camera.near = 0.5;\n        spotLight.shadow.camera.far = 50;\n        scene.add(spotLight);\n\n        // 5. Crear el objeto a iluminar\n        const geometry = new THREE.TorusKnotGeometry(1, 0.4, 100, 16);\n        const material = new THREE.MeshStandardMaterial({ color: 0x156289, emissive: 0x072534, metalness: 0.5, roughness: 0.1 });\n        const torusKnot = new THREE.Mesh(geometry, material);\n        torusKnot.castShadow = true; // El objeto proyecta sombras\n        torusKnot.receiveShadow = true; // El objeto puede recibir sombras\n        scene.add(torusKnot);\n\n        // 6. Crear el suelo con textura\n        const floorGeometry = new THREE.PlaneGeometry(50, 50);\n        const textureLoader = new THREE.TextureLoader();\n        const floorTexture = textureLoader.load('textures/floor_texture.jpg');\n        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;\n        floorTexture.repeat.set(10, 10);\n        const floorMaterial = new THREE.MeshStandardMaterial({ map: floorTexture });\n        const floor = new THREE.Mesh(floorGeometry, floorMaterial);\n        floor.rotation.x = -Math.PI / 2; // Rotar para que quede horizontal\n        floor.position.y = -3;\n        floor.receiveShadow = true; // El suelo recibe sombras\n        scene.add(floor);\n\n        // 7. Funci\u00f3n de animaci\u00f3n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            // Rotar el objeto\n            torusKnot.rotation.x += 0.01;\n            torusKnot.rotation.y += 0.01;\n\n            // Renderizar la escena\n            renderer.render(scene, camera);\n        }\n\n        animate();\n\n        // 8. Manejar el redimensionamiento de la ventana\n        window.addEventListener('resize', () =&gt; {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n\n            renderer.setSize(width, height);\n            camera.aspect = width / height;\n            camera.updateProjectionMatrix();\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Explicaci\u00f3n del C\u00f3digo:</p> <ol> <li>SpotLight:</li> <li>Se crea una <code>SpotLight</code> blanca con intensidad 1.</li> <li>Posicionada en <code>(0, 10, 10)</code> y apuntando hacia el centro de la escena.</li> <li>Configurada con un \u00e1ngulo de cono de <code>Math.PI / 6</code> (30 grados) y una penumbra de 0.1 para transiciones suaves.</li> <li> <p>Habilitada para proyectar sombras y configurada para mejorar la calidad de las sombras.</p> </li> <li> <p>Objeto Iluminado:</p> </li> <li>Se crea un <code>TorusKnotGeometry</code> con un material <code>MeshStandardMaterial</code> que responde a la iluminaci\u00f3n.</li> <li> <p>El objeto est\u00e1 configurado para proyectar y recibir sombras.</p> </li> <li> <p>Suelo con Textura:</p> </li> <li>Se crea un plano grande que act\u00faa como suelo.</li> <li>Se carga una textura (<code>floor_texture.jpg</code>) y se aplica al material del suelo.</li> <li>La textura se repite varias veces para cubrir toda la superficie del suelo.</li> <li> <p>El suelo est\u00e1 configurado para recibir sombras.</p> </li> <li> <p>Animaci\u00f3n:</p> </li> <li>Se rota el <code>TorusKnot</code> en cada frame para mostrar la interacci\u00f3n de las sombras din\u00e1micas con la luz.</li> </ol> <p>Resultado Esperado:</p> <p>Una escena con un <code>TorusKnot</code> giratorio iluminado por una <code>SpotLight</code>, proyectando sombras din\u00e1micas sobre un suelo texturizado. La luz focalizada del <code>SpotLight</code> crea \u00e1reas iluminadas y sombras realistas, mejorando el realismo de la escena.</p>"},{"location":"Curso/4.%20Luces%20en%20Three.js/#47-mejores-practicas","title":"4.7 Mejores Pr\u00e1cticas","text":"<p>Uso de Helpers para Depuraci\u00f3n:    - Utiliza <code>THREE.DirectionalLightHelper</code>, <code>THREE.SpotLightHelper</code> y otros helpers para visualizar y ajustar las posiciones y direcciones de las luces durante el desarrollo.</p> <p>Ejemplo de Uso de Helpers:</p> <pre><code>// A\u00f1adir un helper para la DirectionalLight\nconst directionalLightHelper = new THREE.DirectionalLightHelper(directionalLight, 5);\nscene.add(directionalLightHelper);\n\n// A\u00f1adir un helper para la SpotLight\nconst spotLightHelper = new THREE.SpotLightHelper(spotLight);\nscene.add(spotLightHelper);\n\n// Actualizar los helpers en la animaci\u00f3n si la luz se mueve\nfunction animate() {\n    requestAnimationFrame(animate);\n\n    // Rotar el objeto\n    torusKnot.rotation.x += 0.01;\n    torusKnot.rotation.y += 0.01;\n\n    // Actualizar helpers\n    directionalLightHelper.update();\n    spotLightHelper.update();\n\n    // Renderizar la escena\n    renderer.render(scene, camera);\n}\n\nanimate();\n</code></pre>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/","title":"5. C\u00e1maras y Control de la C\u00e1mara","text":""},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#51-introduccion-a-las-camaras","title":"5.1 Introducci\u00f3n a las C\u00e1maras","text":"<p>En Three.js, la c\u00e1mara es el punto de vista desde el cual observas la escena 3D. Define qu\u00e9 parte de la escena es visible y c\u00f3mo se proyecta en la pantalla. Seleccionar y configurar adecuadamente la c\u00e1mara es esencial para lograr la composici\u00f3n deseada y una experiencia de usuario fluida.</p>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#52-tipos-de-camaras-en-threejs","title":"5.2 Tipos de C\u00e1maras en Three.js","text":"<p>Three.js ofrece principalmente dos tipos de c\u00e1maras: C\u00e1mara en Perspectiva (<code>PerspectiveCamera</code>) y C\u00e1mara Ortogr\u00e1fica (<code>OrthographicCamera</code>). Cada una tiene caracter\u00edsticas y usos espec\u00edficos.</p>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#521-camara-en-perspectiva-perspectivecamera","title":"5.2.1 C\u00e1mara en Perspectiva (<code>PerspectiveCamera</code>)","text":"<p>Descripci\u00f3n:</p> <p>La <code>PerspectiveCamera</code> simula la percepci\u00f3n humana, donde los objetos m\u00e1s lejanos parecen m\u00e1s peque\u00f1os que los cercanos. Es ideal para escenas que requieren profundidad y realismo, como juegos, visualizaciones arquitect\u00f3nicas y entornos inmersivos.</p> <p>Sintaxis:</p> <pre><code>const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n</code></pre> <p>Par\u00e1metros:</p> <ul> <li><code>fov</code> (Field of View): Campo de visi\u00f3n en grados. Define el \u00e1ngulo de visi\u00f3n vertical.</li> <li><code>aspect</code>: Relaci\u00f3n de aspecto, generalmente el ancho de la ventana dividido por su altura.</li> <li><code>near</code>: Plano cercano de recorte. Objetos m\u00e1s cercanos que esta distancia no se renderizan.</li> <li><code>far</code>: Plano lejano de recorte. Objetos m\u00e1s alejados que esta distancia no se renderizan.</li> </ul> <p>Ejemplo:</p> <pre><code>const camera = new THREE.PerspectiveCamera(\n    75, // Campo de visi\u00f3n de 75 grados\n    window.innerWidth / window.innerHeight, // Relaci\u00f3n de aspecto\n    0.1, // Plano cercano\n    1000 // Plano lejano\n);\ncamera.position.set(0, 5, 10); // Posicionar la c\u00e1mara\ncamera.lookAt(0, 0, 0); // Orientar la c\u00e1mara hacia el centro de la escena\n</code></pre>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#522-camara-ortografica-orthographiccamera","title":"5.2.2 C\u00e1mara Ortogr\u00e1fica (<code>OrthographicCamera</code>)","text":"<p>Descripci\u00f3n:</p> <p>La <code>OrthographicCamera</code> muestra los objetos sin perspectiva, es decir, mantiene las mismas dimensiones independientemente de la distancia al observador. Es \u00fatil para aplicaciones donde la precisi\u00f3n y la escala son importantes, como diagramas t\u00e9cnicos, editores 2D o juegos de estilo isom\u00e9trico.</p> <p>Sintaxis:</p> <pre><code>const camera = new THREE.OrthographicCamera(left, right, top, bottom, near, far);\n</code></pre> <p>Par\u00e1metros:</p> <ul> <li><code>left</code>, <code>right</code>, <code>top</code>, <code>bottom</code>: Definen el tama\u00f1o del volumen de visualizaci\u00f3n ortogr\u00e1fica.</li> <li><code>near</code>: Plano cercano de recorte.</li> <li><code>far</code>: Plano lejano de recorte.</li> </ul> <p>Ejemplo:</p> <pre><code>const aspect = window.innerWidth / window.innerHeight;\nconst camera = new THREE.OrthographicCamera(\n    -10 * aspect, // left\n    10 * aspect,  // right\n    10,           // top\n    -10,          // bottom\n    0.1,          // near\n    1000          // far\n);\ncamera.position.set(0, 10, 10); // Posicionar la c\u00e1mara\ncamera.lookAt(0, 0, 0); // Orientar la c\u00e1mara hacia el centro de la escena\n</code></pre>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#53-configuracion-de-parametros-importantes","title":"5.3 Configuraci\u00f3n de Par\u00e1metros Importantes","text":""},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#531-campo-de-vision-fov","title":"5.3.1 Campo de Visi\u00f3n (<code>fov</code>)","text":"<p>El <code>fov</code> define el \u00e1ngulo de visi\u00f3n vertical de la c\u00e1mara en grados. Un valor mayor proporciona una visi\u00f3n m\u00e1s amplia, pero puede distorsionar la perspectiva, mientras que un valor menor enfoca m\u00e1s en un \u00e1rea espec\u00edfica.</p> <p>Recomendaci\u00f3n:</p> <p>Un <code>fov</code> entre 60 y 75 grados suele ser adecuado para la mayor\u00eda de las aplicaciones, ya que proporciona una buena perspectiva sin exagerar la distorsi\u00f3n.</p>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#532-relacion-de-aspecto-aspect","title":"5.3.2 Relaci\u00f3n de Aspecto (<code>aspect</code>)","text":"<p>La relaci\u00f3n de aspecto es la proporci\u00f3n entre el ancho y la altura de la ventana de visualizaci\u00f3n. Es crucial para evitar distorsiones en la escena.</p> <p>Ejemplo:</p> <pre><code>const aspect = window.innerWidth / window.innerHeight;\ncamera.aspect = aspect;\ncamera.updateProjectionMatrix();\n</code></pre>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#533-planos-de-recorte-near-y-far","title":"5.3.3 Planos de Recorte (<code>near</code> y <code>far</code>)","text":"<ul> <li> <p><code>near</code>: Define la distancia m\u00ednima a la que la c\u00e1mara empieza a renderizar objetos. Un valor muy cercano puede causar problemas de precisi\u00f3n, mientras que un valor muy lejano puede recortar objetos cercanos.</p> </li> <li> <p><code>far</code>: Define la distancia m\u00e1xima a la que la c\u00e1mara deja de renderizar objetos. Debe ser lo suficientemente grande para incluir todos los objetos de inter\u00e9s, pero no demasiado grande para evitar problemas de precisi\u00f3n.</p> </li> </ul> <p>Recomendaci\u00f3n:</p> <p>Mant\u00e9n el rango entre <code>near</code> y <code>far</code> lo m\u00e1s estrecho posible para optimizar la profundidad de la escena y mejorar el rendimiento.</p>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#54-controles-de-la-camara","title":"5.4 Controles de la C\u00e1mara","text":"<p>Para mejorar la experiencia de usuario, es com\u00fan implementar controles que permitan interactuar con la c\u00e1mara, como rotar, acercar o alejar la vista. Three.js proporciona <code>OrbitControls</code> para este prop\u00f3sito.</p>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#541-orbitcontrols","title":"5.4.1 <code>OrbitControls</code>","text":"<p>Descripci\u00f3n:</p> <p><code>OrbitControls</code> permite rotar, acercar y alejar la c\u00e1mara alrededor de un punto objetivo. Es ideal para aplicaciones donde el usuario necesita explorar la escena desde diferentes \u00e1ngulos.</p> <p>Instalaci\u00f3n:</p> <p>Si est\u00e1s utilizando un CDN, puedes incluir <code>OrbitControls</code> directamente desde el repositorio de Three.js.</p> <pre><code>&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/examples/js/controls/OrbitControls.js\"&gt;&lt;/script&gt;\n</code></pre> <p>Si est\u00e1s utilizando m\u00f3dulos ES6 con <code>import</code>, aseg\u00farate de importar correctamente <code>OrbitControls</code>.</p> <p>Uso B\u00e1sico:</p> <pre><code>// Crear los controles despu\u00e9s de haber creado la c\u00e1mara y el renderizador\nconst controls = new THREE.OrbitControls(camera, renderer.domElement);\n\n// Configurar opciones de los controles\ncontrols.enableDamping = true; // Habilita la inercia\ncontrols.dampingFactor = 0.05; // Factor de inercia\ncontrols.screenSpacePanning = false; // Deshabilita el desplazamiento en el espacio de la pantalla\ncontrols.minDistance = 5; // Distancia m\u00ednima al objeto\ncontrols.maxDistance = 50; // Distancia m\u00e1xima al objeto\ncontrols.maxPolarAngle = Math.PI / 2; // Limita la rotaci\u00f3n vertical a 90 grados\n</code></pre> <p>Actualizaci\u00f3n en el Ciclo de Animaci\u00f3n:</p> <p>Es importante actualizar los controles en cada frame para que las animaciones de inercia funcionen correctamente.</p> <pre><code>function animate() {\n    requestAnimationFrame(animate);\n\n    controls.update(); // Actualiza los controles\n\n    renderer.render(scene, camera);\n}\n\nanimate();\n</code></pre> <p>Opciones Avanzadas:</p> <ul> <li> <p><code>controls.target</code>: Define el punto alrededor del cual la c\u00e1mara orbita. Por defecto, es <code>(0, 0, 0)</code>.</p> <p><code>javascript controls.target.set(0, 0, 0);</code></p> </li> <li> <p><code>controls.enableZoom</code>: Habilita o deshabilita el zoom.</p> <p><code>javascript controls.enableZoom = true;</code></p> </li> <li> <p><code>controls.enableRotate</code>: Habilita o deshabilita la rotaci\u00f3n.</p> <p><code>javascript controls.enableRotate = true;</code></p> </li> <li> <p><code>controls.enablePan</code>: Habilita o deshabilita el desplazamiento lateral.</p> <p><code>javascript controls.enablePan = true;</code></p> </li> </ul>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#55-ejemplo-completo-camara-en-perspectiva-con-orbitcontrols","title":"5.5 Ejemplo Completo: C\u00e1mara en Perspectiva con <code>OrbitControls</code>","text":"<p>A continuaci\u00f3n, se presenta un ejemplo completo que integra una <code>PerspectiveCamera</code> con <code>OrbitControls</code>, permitiendo al usuario interactuar con la c\u00e1mara para explorar la escena.</p>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#551-estructura-de-carpetas","title":"5.5.1 Estructura de Carpetas","text":"<pre><code>mi-escena-camara-threejs/\n\u251c\u2500\u2500 index.html\n\u251c\u2500\u2500 js/\n\u2502   \u2514\u2500\u2500 three.min.js\n\u2514\u2500\u2500 examples/\n    \u2514\u2500\u2500 OrbitControls.js\n</code></pre>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#552-contenido-de-indexhtml","title":"5.5.2 Contenido de <code>index.html</code>","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;C\u00e1mara y Controles en Three.js&lt;/title&gt;\n    &lt;style&gt;\n        body { margin: 0; }\n        canvas { display: block; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- Enlace a Three.js --&gt;\n    &lt;script src=\"js/three.min.js\"&gt;&lt;/script&gt;\n    &lt;!-- Enlace a OrbitControls --&gt;\n    &lt;script src=\"examples/OrbitControls.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n        // 1. Crear la escena\n        const scene = new THREE.Scene();\n        scene.background = new THREE.Color(0xdddddd);\n\n        // 2. Crear la c\u00e1mara en perspectiva\n        const camera = new THREE.PerspectiveCamera(\n            75, // Campo de visi\u00f3n\n            window.innerWidth / window.innerHeight, // Relaci\u00f3n de aspecto\n            0.1, // Plano cercano\n            1000 // Plano lejano\n        );\n        camera.position.set(0, 5, 10); // Posicionar la c\u00e1mara\n        camera.lookAt(0, 0, 0); // Orientar la c\u00e1mara hacia el centro de la escena\n\n        // 3. Crear el renderizador\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        document.body.appendChild(renderer.domElement);\n\n        // 4. A\u00f1adir OrbitControls\n        const controls = new THREE.OrbitControls(camera, renderer.domElement);\n        controls.enableDamping = true; // Habilitar inercia\n        controls.dampingFactor = 0.05; // Factor de inercia\n        controls.minDistance = 5; // Distancia m\u00ednima\n        controls.maxDistance = 50; // Distancia m\u00e1xima\n        controls.maxPolarAngle = Math.PI / 2; // Limitar rotaci\u00f3n vertical\n\n        // 5. A\u00f1adir una luz ambiental\n        const ambientLight = new THREE.AmbientLight(0x404040, 1); // Luz ambiental suave\n        scene.add(ambientLight);\n\n        // 6. A\u00f1adir una luz direccional\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n        directionalLight.position.set(5, 10, 7.5);\n        directionalLight.castShadow = true; // La luz proyecta sombras\n\n        // Configuraci\u00f3n de sombras para la luz direccional\n        directionalLight.shadow.mapSize.width = 1024;\n        directionalLight.shadow.mapSize.height = 1024;\n        directionalLight.shadow.camera.near = 0.5;\n        directionalLight.shadow.camera.far = 50;\n        directionalLight.shadow.camera.left = -10;\n        directionalLight.shadow.camera.right = 10;\n        directionalLight.shadow.camera.top = 10;\n        directionalLight.shadow.camera.bottom = -10;\n\n        scene.add(directionalLight);\n\n        // 7. Crear un cubo que proyecta y recibe sombras\n        const geometry = new THREE.BoxGeometry(2, 2, 2);\n        const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });\n        const cube = new THREE.Mesh(geometry, material);\n        cube.castShadow = true; // El cubo proyecta sombras\n        cube.receiveShadow = true; // El cubo puede recibir sombras\n        scene.add(cube);\n\n        // 8. Crear el suelo que recibe sombras\n        const floorGeometry = new THREE.PlaneGeometry(20, 20);\n        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });\n        const floor = new THREE.Mesh(floorGeometry, floorMaterial);\n        floor.rotation.x = -Math.PI / 2; // Rotar para que quede horizontal\n        floor.position.y = -1;\n        floor.receiveShadow = true; // El suelo recibe sombras\n        scene.add(floor);\n\n        // 9. Funci\u00f3n de animaci\u00f3n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            controls.update(); // Actualizar los controles\n\n            renderer.render(scene, camera);\n        }\n\n        animate();\n\n        // 10. Manejar el redimensionamiento de la ventana\n        window.addEventListener('resize', () =&gt; {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n\n            renderer.setSize(width, height);\n            camera.aspect = width / height;\n            camera.updateProjectionMatrix();\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#553-explicacion-del-codigo","title":"5.5.3 Explicaci\u00f3n del C\u00f3digo","text":"<ol> <li>Escena y C\u00e1mara:</li> <li>Se crea una escena con un fondo de color gris claro.</li> <li>Se configura una <code>PerspectiveCamera</code> con un campo de visi\u00f3n de 75 grados, una relaci\u00f3n de aspecto basada en el tama\u00f1o de la ventana y planos de recorte cercanos y lejanos de 0.1 y 1000, respectivamente.</li> <li> <p>La c\u00e1mara se posiciona en <code>(0, 5, 10)</code> y mira hacia el centro de la escena.</p> </li> <li> <p>Renderizador:</p> </li> <li>Se crea un <code>WebGLRenderer</code> con antialiasing habilitado para suavizar los bordes de los objetos.</li> <li> <p>El renderizador se ajusta al tama\u00f1o de la ventana y se a\u00f1ade al documento HTML.</p> </li> <li> <p>OrbitControls:</p> </li> <li>Se instancia <code>OrbitControls</code> pasando la c\u00e1mara y el renderizador como par\u00e1metros.</li> <li>Se habilita la inercia (<code>enableDamping</code>) para que los movimientos de la c\u00e1mara sean m\u00e1s suaves.</li> <li>Se establecen l\u00edmites de distancia m\u00ednima y m\u00e1xima para evitar acercamientos excesivos o alejamientos que puedan comprometer la visibilidad de la escena.</li> <li> <p>Se limita la rotaci\u00f3n vertical para evitar que la c\u00e1mara se coloque debajo del suelo.</p> </li> <li> <p>Iluminaci\u00f3n:</p> </li> <li>AmbientLight: Proporciona una iluminaci\u00f3n base suave en toda la escena.</li> <li> <p>DirectionalLight: Simula una luz direccional (como el sol), posicionada en <code>(5, 10, 7.5)</code> y configurada para proyectar sombras. Se ajustan sus propiedades de sombra para mejorar la calidad visual.</p> </li> <li> <p>Objetos:</p> </li> <li>Cubo: Un objeto verde con <code>MeshStandardMaterial</code> que responde a la iluminaci\u00f3n. Est\u00e1 configurado para proyectar y recibir sombras.</li> <li> <p>Suelo: Un plano gris que act\u00faa como suelo, rotado para quedar horizontal y posicionado debajo del cubo. Est\u00e1 configurado para recibir sombras.</p> </li> <li> <p>Animaci\u00f3n:</p> </li> <li> <p>Se define una funci\u00f3n <code>animate</code> que se ejecuta en cada frame, actualizando los controles de la c\u00e1mara y renderizando la escena.</p> </li> <li> <p>Redimensionamiento:</p> </li> <li>Se a\u00f1ade un evento que ajusta el tama\u00f1o del renderizador y la c\u00e1mara cuando la ventana cambia de tama\u00f1o, manteniendo la proporci\u00f3n y la calidad visual.</li> </ol>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#56-ejemplo-completo-camara-ortografica-con-controles-personalizados","title":"5.6 Ejemplo Completo: C\u00e1mara Ortogr\u00e1fica con Controles Personalizados","text":"<p>Para contrastar con el ejemplo anterior, a continuaci\u00f3n se presenta un ejemplo que utiliza una <code>OrthographicCamera</code> junto con <code>OrbitControls</code>, permitiendo una visualizaci\u00f3n sin perspectiva de la escena.</p>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#561-estructura-de-carpetas","title":"5.6.1 Estructura de Carpetas","text":"<pre><code>mi-escena-ortografica-threejs/\n\u251c\u2500\u2500 index.html\n\u251c\u2500\u2500 js/\n\u2502   \u2514\u2500\u2500 three.min.js\n\u2514\u2500\u2500 examples/\n    \u2514\u2500\u2500 OrbitControls.js\n</code></pre>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#562-contenido-de-indexhtml","title":"5.6.2 Contenido de <code>index.html</code>","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;C\u00e1mara Ortogr\u00e1fica en Three.js&lt;/title&gt;\n    &lt;style&gt;\n        body { margin: 0; }\n        canvas { display: block; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- Enlace a Three.js --&gt;\n    &lt;script src=\"js/three.min.js\"&gt;&lt;/script&gt;\n    &lt;!-- Enlace a OrbitControls --&gt;\n    &lt;script src=\"examples/OrbitControls.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n        // 1. Crear la escena\n        const scene = new THREE.Scene();\n        scene.background = new THREE.Color(0xeeeeee);\n\n        // 2. Crear la c\u00e1mara ortogr\u00e1fica\n        const aspect = window.innerWidth / window.innerHeight;\n        const camera = new THREE.OrthographicCamera(\n            -10 * aspect, // left\n            10 * aspect,  // right\n            10,           // top\n            -10,          // bottom\n            0.1,          // near\n            1000          // far\n        );\n        camera.position.set(20, 20, 20); // Posicionar la c\u00e1mara\n        camera.lookAt(0, 0, 0); // Orientar la c\u00e1mara hacia el centro de la escena\n\n        // 3. Crear el renderizador\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        document.body.appendChild(renderer.domElement);\n\n        // 4. A\u00f1adir OrbitControls\n        const controls = new THREE.OrbitControls(camera, renderer.domElement);\n        controls.enableDamping = true; // Habilitar inercia\n        controls.dampingFactor = 0.05; // Factor de inercia\n        controls.enableZoom = true; // Habilitar zoom\n        controls.enableRotate = true; // Habilitar rotaci\u00f3n\n        controls.enablePan = true; // Habilitar desplazamiento\n        controls.minZoom = 0.5; // Zoom m\u00ednimo\n        controls.maxZoom = 2;   // Zoom m\u00e1ximo\n\n        // 5. A\u00f1adir una luz ambiental\n        const ambientLight = new THREE.AmbientLight(0x404040, 1); // Luz ambiental suave\n        scene.add(ambientLight);\n\n        // 6. A\u00f1adir una luz direccional\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n        directionalLight.position.set(10, 20, 10);\n        directionalLight.castShadow = true; // La luz proyecta sombras\n\n        // Configuraci\u00f3n de sombras para la luz direccional\n        directionalLight.shadow.mapSize.width = 1024;\n        directionalLight.shadow.mapSize.height = 1024;\n        directionalLight.shadow.camera.near = 0.5;\n        directionalLight.shadow.camera.far = 50;\n        directionalLight.shadow.camera.left = -15;\n        directionalLight.shadow.camera.right = 15;\n        directionalLight.shadow.camera.top = 15;\n        directionalLight.shadow.camera.bottom = -15;\n\n        scene.add(directionalLight);\n\n        // 7. Crear una esfera que proyecta y recibe sombras\n        const geometry = new THREE.SphereGeometry(3, 32, 32);\n        const material = new THREE.MeshStandardMaterial({ color: 0x0077ff });\n        const sphere = new THREE.Mesh(geometry, material);\n        sphere.castShadow = true; // La esfera proyecta sombras\n        sphere.receiveShadow = true; // La esfera puede recibir sombras\n        scene.add(sphere);\n\n        // 8. Crear el suelo que recibe sombras\n        const floorGeometry = new THREE.PlaneGeometry(50, 50);\n        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });\n        const floor = new THREE.Mesh(floorGeometry, floorMaterial);\n        floor.rotation.x = -Math.PI / 2; // Rotar para que quede horizontal\n        floor.position.y = -5;\n        floor.receiveShadow = true; // El suelo recibe sombras\n        scene.add(floor);\n\n        // 9. Funci\u00f3n de animaci\u00f3n\n        function animate() {\n            requestAnimationFrame(animate);\n\n            controls.update(); // Actualizar los controles\n\n            renderer.render(scene, camera);\n        }\n\n        animate();\n\n        // 10. Manejar el redimensionamiento de la ventana\n        window.addEventListener('resize', () =&gt; {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n\n            // Actualizar la relaci\u00f3n de aspecto y los par\u00e1metros de la c\u00e1mara ortogr\u00e1fica\n            const aspect = width / height;\n            camera.left = -10 * aspect;\n            camera.right = 10 * aspect;\n            camera.top = 10;\n            camera.bottom = -10;\n            camera.updateProjectionMatrix();\n\n            renderer.setSize(width, height);\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#563-explicacion-del-codigo","title":"5.6.3 Explicaci\u00f3n del C\u00f3digo","text":"<ol> <li>Escena y C\u00e1mara:</li> <li>Se crea una escena con un fondo gris claro.</li> <li> <p>Se configura una <code>OrthographicCamera</code> con un volumen de visualizaci\u00f3n que depende de la relaci\u00f3n de aspecto de la ventana. La c\u00e1mara se posiciona en <code>(20, 20, 20)</code> y mira hacia el centro de la escena.</p> </li> <li> <p>Renderizador:</p> </li> <li>Se crea un <code>WebGLRenderer</code> con antialiasing habilitado para suavizar los bordes de los objetos.</li> <li> <p>El renderizador se ajusta al tama\u00f1o de la ventana y se a\u00f1ade al documento HTML.</p> </li> <li> <p>OrbitControls:</p> </li> <li>Se instancia <code>OrbitControls</code> pasando la c\u00e1mara y el renderizador como par\u00e1metros.</li> <li>Se habilita la inercia (<code>enableDamping</code>) para movimientos suaves.</li> <li>Se establecen l\u00edmites de zoom m\u00ednimo y m\u00e1ximo para controlar el acercamiento y alejamiento.</li> <li> <p>Se habilitan todas las interacciones posibles: zoom, rotaci\u00f3n y desplazamiento.</p> </li> <li> <p>Iluminaci\u00f3n:</p> </li> <li>AmbientLight: Proporciona una iluminaci\u00f3n base suave en toda la escena.</li> <li> <p>DirectionalLight: Simula una luz direccional (como el sol), posicionada en <code>(10, 20, 10)</code> y configurada para proyectar sombras. Se ajustan sus propiedades de sombra para mejorar la calidad visual.</p> </li> <li> <p>Objetos:</p> </li> <li>Esfera: Un objeto azul con <code>MeshStandardMaterial</code> que responde a la iluminaci\u00f3n. Est\u00e1 configurado para proyectar y recibir sombras.</li> <li> <p>Suelo: Un plano gris que act\u00faa como suelo, rotado para quedar horizontal y posicionado debajo de la esfera. Est\u00e1 configurado para recibir sombras.</p> </li> <li> <p>Animaci\u00f3n:</p> </li> <li> <p>Se define una funci\u00f3n <code>animate</code> que se ejecuta en cada frame, actualizando los controles de la c\u00e1mara y renderizando la escena.</p> </li> <li> <p>Redimensionamiento:</p> </li> <li>Se a\u00f1ade un evento que ajusta el tama\u00f1o del renderizador y actualiza los par\u00e1metros de la c\u00e1mara ortogr\u00e1fica cuando la ventana cambia de tama\u00f1o, manteniendo la proporci\u00f3n y evitando distorsiones.</li> </ol>"},{"location":"Curso/5.%20C%C3%A1maras%20y%20Control%20de%20la%20C%C3%A1mara/#57-mejores-practicas","title":"5.7 Mejores Pr\u00e1cticas","text":"<ol> <li>Usar Helpers para Depuraci\u00f3n:</li> <li>Emplea <code>THREE.CameraHelper</code> para visualizar el volumen de la c\u00e1mara y asegurarte de que est\u00e1 configurada correctamente.</li> <li>Los helpers facilitan la depuraci\u00f3n y el ajuste fino de la configuraci\u00f3n de la c\u00e1mara.</li> </ol> <p>Ejemplo de Uso de <code>CameraHelper</code>:</p> <pre><code>// Crear un helper para la c\u00e1mara direccional\nconst directionalLightHelper = new THREE.DirectionalLightHelper(directionalLight, 5);\nscene.add(directionalLightHelper);\n\n// Crear un helper para la c\u00e1mara\nconst cameraHelper = new THREE.CameraHelper(camera);\nscene.add(cameraHelper);\n</code></pre>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/","title":"6. Creaci\u00f3n y Manipulaci\u00f3n de Objetos 3D","text":""},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#61-introduccion-a-las-mallas-threemesh","title":"6.1 Introducci\u00f3n a las Mallas (<code>THREE.Mesh</code>)","text":"<p>En Three.js, las mallas (<code>Mesh</code>) son los objetos b\u00e1sicos que representan formas 3D en una escena. Una malla combina una geometr\u00eda (la forma) con un material (la apariencia visual), permitiendo as\u00ed que los objetos tengan una forma definida y una apariencia determinada.</p>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#62-creacion-de-mallas-threemesh","title":"6.2 Creaci\u00f3n de Mallas (<code>THREE.Mesh</code>)","text":"<p>Una malla en Three.js se crea combinando una geometr\u00eda con un material. A continuaci\u00f3n, se muestra c\u00f3mo crear y a\u00f1adir una malla simple a una escena.</p>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#621-sintaxis-basica-de-threemesh","title":"6.2.1 Sintaxis B\u00e1sica de <code>THREE.Mesh</code>","text":"<pre><code>const malla = new THREE.Mesh(geometria, material);\nscene.add(malla);\n</code></pre> <ul> <li><code>geometria</code>: Define la forma del objeto (por ejemplo, <code>BoxGeometry</code>, <code>SphereGeometry</code>, etc.).</li> <li><code>material</code>: Define la apariencia del objeto (por ejemplo, <code>MeshBasicMaterial</code>, <code>MeshStandardMaterial</code>, etc.).</li> </ul>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#622-ejemplo-crear-un-cubo-verde","title":"6.2.2 Ejemplo: Crear un Cubo Verde","text":"<p>A continuaci\u00f3n, se presenta un ejemplo completo que crea un cubo verde y lo a\u00f1ade a la escena.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Malla B\u00e1sica en Three.js&lt;/title&gt;\n    &lt;style&gt;\n        body { margin: 0; }\n        canvas { display: block; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- Enlace a Three.js --&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n        // 1. Crear la escena\n        const escena = new THREE.Scene();\n\n        // 2. Crear la c\u00e1mara\n        const camara = new THREE.PerspectiveCamera(\n            75, // Campo de visi\u00f3n\n            window.innerWidth / window.innerHeight, // Relaci\u00f3n de aspecto\n            0.1, // Plano cercano\n            1000 // Plano lejano\n        );\n        camara.position.z = 5; // Posicionar la c\u00e1mara\n\n        // 3. Crear el renderizador\n        const renderizador = new THREE.WebGLRenderer({ antialias: true });\n        renderizador.setSize(window.innerWidth, window.innerHeight);\n        document.body.appendChild(renderizador.domElement);\n\n        // 4. Crear la geometr\u00eda y el material\n        const geometriaCubo = new THREE.BoxGeometry(1, 1, 1); // Geometr\u00eda de caja\n        const materialVerde = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Material verde b\u00e1sico\n\n        // 5. Crear la malla y a\u00f1adirla a la escena\n        const cubo = new THREE.Mesh(geometriaCubo, materialVerde);\n        escena.add(cubo);\n\n        // 6. Funci\u00f3n de animaci\u00f3n\n        function animar() {\n            requestAnimationFrame(animar);\n\n            // Rotar el cubo\n            cubo.rotation.x += 0.01;\n            cubo.rotation.y += 0.01;\n\n            // Renderizar la escena\n            renderizador.render(escena, camara);\n        }\n\n        animar(); // Iniciar la animaci\u00f3n\n\n        // 7. Manejar el redimensionamiento de la ventana\n        window.addEventListener('resize', () =&gt; {\n            const ancho = window.innerWidth;\n            const alto = window.innerHeight;\n\n            renderizador.setSize(ancho, alto);\n            camara.aspect = ancho / alto;\n            camara.updateProjectionMatrix();\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Resultado Esperado:</p> <p>Al abrir el archivo HTML en tu navegador, deber\u00edas ver un cubo verde girando en el centro de la pantalla.</p>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#63-transformaciones-de-objetos-traslacion-rotacion-y-escalado","title":"6.3 Transformaciones de Objetos: Traslaci\u00f3n, Rotaci\u00f3n y Escalado","text":"<p>Las transformaciones permiten modificar la posici\u00f3n, orientaci\u00f3n y tama\u00f1o de los objetos en la escena. Three.js proporciona m\u00e9todos y propiedades para aplicar estas transformaciones de manera sencilla.</p>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#631-traslacion-movimiento","title":"6.3.1 Traslaci\u00f3n (Movimiento)","text":"<p>Descripci\u00f3n:</p> <p>La traslaci\u00f3n mueve un objeto de un lugar a otro en el espacio 3D.</p> <p>Propiedades Principales:</p> <ul> <li><code>position.x</code>: Movimiento a lo largo del eje X.</li> <li><code>position.y</code>: Movimiento a lo largo del eje Y.</li> <li><code>position.z</code>: Movimiento a lo largo del eje Z.</li> </ul> <p>Ejemplo: Mover un Cubo hacia la Derecha y Arriba</p> <pre><code>cubo.position.x += 2; // Mover 2 unidades a la derecha\ncubo.position.y += 1; // Mover 1 unidad hacia arriba\n</code></pre>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#632-rotacion","title":"6.3.2 Rotaci\u00f3n","text":"<p>Descripci\u00f3n:</p> <p>La rotaci\u00f3n gira un objeto alrededor de uno o m\u00e1s ejes.</p> <p>Propiedades Principales:</p> <ul> <li><code>rotation.x</code>: Rotaci\u00f3n alrededor del eje X (en radianes).</li> <li><code>rotation.y</code>: Rotaci\u00f3n alrededor del eje Y (en radianes).</li> <li><code>rotation.z</code>: Rotaci\u00f3n alrededor del eje Z (en radianes).</li> </ul> <p>Ejemplo: Rotar un Cubo 45 Grados en el Eje Y</p> <pre><code>const grados = 45;\nconst radianes = grados * (Math.PI / 180);\ncubo.rotation.y += radianes; // Rotar 45 grados en el eje Y\n</code></pre>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#633-escalado","title":"6.3.3 Escalado","text":"<p>Descripci\u00f3n:</p> <p>El escalado cambia el tama\u00f1o de un objeto en una o m\u00e1s direcciones.</p> <p>Propiedades Principales:</p> <ul> <li><code>scale.x</code>: Escalado a lo largo del eje X.</li> <li><code>scale.y</code>: Escalado a lo largo del eje Y.</li> <li><code>scale.z</code>: Escalado a lo largo del eje Z.</li> </ul> <p>Ejemplo: Escalar un Cubo al Doble de su Tama\u00f1o Original</p> <pre><code>cubo.scale.set(2, 2, 2); // Escalar en X, Y y Z al doble\n</code></pre>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#634-metodos-de-transformacion","title":"6.3.4 M\u00e9todos de Transformaci\u00f3n","text":"<p>Adem\u00e1s de las propiedades mencionadas, Three.js ofrece m\u00e9todos para aplicar transformaciones de manera m\u00e1s controlada.</p> <ul> <li><code>translateX(distance)</code>: Trasladar el objeto a lo largo del eje X.</li> <li><code>translateY(distance)</code>: Trasladar el objeto a lo largo del eje Y.</li> <li><code>translateZ(distance)</code>: Trasladar el objeto a lo largo del eje Z.</li> <li><code>rotateX(angle)</code>: Rotar el objeto alrededor del eje X.</li> <li><code>rotateY(angle)</code>: Rotar el objeto alrededor del eje Y.</li> <li><code>rotateZ(angle)</code>: Rotar el objeto alrededor del eje Z.</li> <li><code>scale.set(x, y, z)</code>: Establecer el escalado en los tres ejes.</li> </ul> <p>Ejemplo: Aplicar Transformaciones Usando M\u00e9todos</p> <pre><code>// Trasladar\ncubo.translateX(1); // Mover 1 unidad a la derecha\n\n// Rotar\ncubo.rotateY(Math.PI / 4); // Rotar 45 grados alrededor del eje Y\n\n// Escalar\ncubo.scale.set(1.5, 1.5, 1.5); // Escalar al 150% en todos los ejes\n</code></pre>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#64-agrupar-objetos-threegroup","title":"6.4 Agrupar Objetos (<code>THREE.Group</code>)","text":"<p>La agrupaci\u00f3n de objetos permite manejar m\u00faltiples mallas como una sola entidad, facilitando su manipulaci\u00f3n conjunta. Esto es \u00fatil para crear estructuras complejas o para aplicar transformaciones a m\u00faltiples objetos simult\u00e1neamente.</p>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#641-crear-y-utilizar-un-grupo","title":"6.4.1 Crear y Utilizar un Grupo","text":"<p>Sintaxis B\u00e1sica:</p> <pre><code>const grupo = new THREE.Group();\ngrupo.add(objeto1);\ngrupo.add(objeto2);\nescena.add(grupo);\n</code></pre> <p>Ejemplo: Agrupar Dos Cubos de Colores Diferentes</p> <pre><code>// 1. Crear la geometr\u00eda y materiales para dos cubos\nconst geometriaCubo = new THREE.BoxGeometry(1, 1, 1);\nconst materialRojo = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Rojo\nconst materialAzul = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // Azul\n\n// 2. Crear dos mallas\nconst cuboRojo = new THREE.Mesh(geometriaCubo, materialRojo);\nconst cuboAzul = new THREE.Mesh(geometriaCubo, materialAzul);\n\n// 3. Posicionar los cubos\ncuboRojo.position.x = -1.5; // A la izquierda\ncuboAzul.position.x = 1.5; // A la derecha\n\n// 4. Crear un grupo y a\u00f1adir los cubos\nconst grupoCubos = new THREE.Group();\ngrupoCubos.add(cuboRojo);\ngrupoCubos.add(cuboAzul);\n\n// 5. A\u00f1adir el grupo a la escena\nescena.add(grupoCubos);\n\n// 6. Aplicar una transformaci\u00f3n al grupo (por ejemplo, rotaci\u00f3n)\nfunction animar() {\n    requestAnimationFrame(animar);\n\n    grupoCubos.rotation.y += 0.01; // Rotar el grupo alrededor del eje Y\n\n    renderizador.render(escena, camara);\n}\n\nanimar();\n</code></pre> <p>Resultado Esperado:</p> <p>Dos cubos (uno rojo y otro azul) agrupados y rotando juntos alrededor del eje Y.</p>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#643-anidar-grupos","title":"6.4.3 Anidar Grupos","text":"<p>Los grupos pueden contener otros grupos, permitiendo una jerarqu\u00eda de objetos. Esto es \u00fatil para estructuras complejas donde diferentes partes tienen transformaciones independientes.</p> <p>Ejemplo: Grupo con Subgrupos</p> <pre><code>// Crear grupos principales\nconst grupoPrincipal = new THREE.Group();\nconst subgrupoIzquierdo = new THREE.Group();\nconst subgrupoDerecho = new THREE.Group();\n\n// Crear mallas para cada subgrupo\nconst cuboVerde = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));\nconst cuboAmarillo = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: 0xffff00 }));\n\n// A\u00f1adir mallas a los subgrupos\nsubgrupoIzquierdo.add(cuboVerde);\nsubgrupoDerecho.add(cuboAmarillo);\n\n// Posicionar los subgrupos\nsubgrupoIzquierdo.position.x = -2;\nsubgrupoDerecho.position.x = 2;\n\n// A\u00f1adir subgrupos al grupo principal\ngrupoPrincipal.add(subgrupoIzquierdo);\ngrupoPrincipal.add(subgrupoDerecho);\n\n// A\u00f1adir el grupo principal a la escena\nescena.add(grupoPrincipal);\n\n// Aplicar transformaciones al grupo principal\nfunction animar() {\n    requestAnimationFrame(animar);\n\n    grupoPrincipal.rotation.y += 0.005; // Rotar el grupo principal\n    subgrupoIzquierdo.rotation.x += 0.01; // Rotar subgrupo izquierdo\n    subgrupoDerecho.rotation.z += 0.01; // Rotar subgrupo derecho\n\n    renderizador.render(escena, camara);\n}\n\nanimar();\n</code></pre> <p>Resultado Esperado:</p> <p>Un grupo principal rotando lentamente alrededor del eje Y, mientras que cada subgrupo (cada uno con un cubo de color diferente) rota de manera independiente alrededor de sus propios ejes.</p>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#65-manipulacion-dinamica-de-objetos","title":"6.5 Manipulaci\u00f3n Din\u00e1mica de Objetos","text":"<p>Adem\u00e1s de las transformaciones est\u00e1ticas, es posible manipular objetos de manera din\u00e1mica en respuesta a eventos del usuario o a otras condiciones en tiempo real.</p>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#651-escuchar-eventos-del-usuario","title":"6.5.1 Escuchar Eventos del Usuario","text":"<p>Puedes modificar las propiedades de los objetos en respuesta a eventos como clics, movimientos del rat\u00f3n, o entradas del teclado.</p> <p>Ejemplo: Cambiar el Color de un Cubo al Hacer Clic</p> <pre><code>// 1. Crear el cubo con MeshStandardMaterial para que pueda reaccionar a la luz\nconst materialCubo = new THREE.MeshStandardMaterial({ color: 0x00ff00 });\nconst cuboInteractivo = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), materialCubo);\nescena.add(cuboInteractivo);\n\n// 2. A\u00f1adir una luz para que el material reaccione a la iluminaci\u00f3n\nconst luzPuntual = new THREE.PointLight(0xffffff, 1);\nluzPuntual.position.set(5, 5, 5);\nescena.add(luzPuntual);\n\n// 3. Detectar clics en el cubo\nwindow.addEventListener('click', () =&gt; {\n    // Generar un color aleatorio\n    const colorAleatorio = Math.random() * 0xffffff;\n    cuboInteractivo.material.color.set(colorAleatorio);\n});\n</code></pre> <p>Resultado Esperado:</p> <p>Al hacer clic en cualquier parte de la ventana, el cubo cambiar\u00e1 a un color aleatorio.</p>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#652-animaciones-basadas-en-eventos","title":"6.5.2 Animaciones Basadas en Eventos","text":"<p>Puedes crear animaciones que respondan a eventos espec\u00edficos, como mover un objeto cuando el usuario presiona una tecla.</p> <p>Ejemplo: Mover un Cubo hacia Arriba al Presionar la Tecla \"W\"</p> <pre><code>// 1. Crear el cubo\nconst geometriaCubo = new THREE.BoxGeometry(1, 1, 1);\nconst materialCubo = new THREE.MeshStandardMaterial({ color: 0x0000ff });\nconst cuboMovil = new THREE.Mesh(geometriaCubo, materialCubo);\nescena.add(cuboMovil);\n\n// 2. A\u00f1adir una luz\nconst luzDireccional = new THREE.DirectionalLight(0xffffff, 1);\nluzDireccional.position.set(5, 10, 7.5);\nescena.add(luzDireccional);\n\n// 3. Escuchar eventos de teclado\nwindow.addEventListener('keydown', (evento) =&gt; {\n    const velocidad = 0.1;\n    switch(evento.key.toLowerCase()) {\n        case 'w':\n            cuboMovil.position.y += velocidad; // Mover hacia arriba\n            break;\n        case 's':\n            cuboMovil.position.y -= velocidad; // Mover hacia abajo\n            break;\n        case 'a':\n            cuboMovil.position.x -= velocidad; // Mover hacia la izquierda\n            break;\n        case 'd':\n            cuboMovil.position.x += velocidad; // Mover hacia la derecha\n            break;\n        default:\n            break;\n    }\n});\n</code></pre> <p>Resultado Esperado:</p> <p>Al presionar las teclas \"W\", \"A\", \"S\" o \"D\", el cubo se mover\u00e1 hacia arriba, izquierda, abajo o derecha, respectivamente.</p>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#66-creacion-de-objetos-compuestos","title":"6.6 Creaci\u00f3n de Objetos Compuestos","text":"<p>A menudo, necesitar\u00e1s crear objetos m\u00e1s complejos combinando m\u00faltiples mallas y formas. Esto se logra utilizando grupos y jerarqu\u00edas de objetos.</p>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#661-ejemplo-crear-un-robot-basico","title":"6.6.1 Ejemplo: Crear un Robot B\u00e1sico","text":"<p>A continuaci\u00f3n, se muestra c\u00f3mo crear una estructura simple que representa un robot utilizando diferentes mallas agrupadas.</p> <pre><code>// 1. Crear el grupo principal del robot\nconst robot = new THREE.Group();\n\n// 2. Crear la cabeza\nconst geometriaCabeza = new THREE.BoxGeometry(1, 1, 1);\nconst materialCabeza = new THREE.MeshStandardMaterial({ color: 0xffd700 }); // Dorado\nconst cabeza = new THREE.Mesh(geometriaCabeza, materialCabeza);\ncabeza.position.y = 2; // Posicionar la cabeza arriba del cuerpo\n\n// 3. Crear el cuerpo\nconst geometriaCuerpo = new THREE.BoxGeometry(2, 2, 1);\nconst materialCuerpo = new THREE.MeshStandardMaterial({ color: 0x00bfff }); // Azul\nconst cuerpo = new THREE.Mesh(geometriaCuerpo, materialCuerpo);\ncuerpo.position.y = 0;\n\n// 4. Crear los brazos\nconst geometriaBrazo = new THREE.BoxGeometry(0.5, 2, 0.5);\nconst materialBrazo = new THREE.MeshStandardMaterial({ color: 0x8b4513 }); // Marr\u00f3n\nconst brazoIzquierdo = new THREE.Mesh(geometriaBrazo, materialBrazo);\nconst brazoDerecho = new THREE.Mesh(geometriaBrazo, materialBrazo);\nbrazoIzquierdo.position.set(-1.5, 1, 0); // Posicionar a la izquierda\nbrazoDerecho.position.set(1.5, 1, 0); // Posicionar a la derecha\n\n// 5. Crear las piernas\nconst geometriaPierna = new THREE.BoxGeometry(0.5, 2, 0.5);\nconst materialPierna = new THREE.MeshStandardMaterial({ color: 0x2e8b57 }); // Verde\nconst piernaIzquierda = new THREE.Mesh(geometriaPierna, materialPierna);\nconst piernaDerecha = new THREE.Mesh(geometriaPierna, materialPierna);\npiernaIzquierda.position.set(-0.5, -2, 0); // Posicionar a la izquierda\npiernaDerecha.position.set(0.5, -2, 0); // Posicionar a la derecha\n\n// 6. A\u00f1adir todas las partes al grupo del robot\nrobot.add(cabeza);\nrobot.add(cuerpo);\nrobot.add(brazoIzquierdo);\nrobot.add(brazoDerecho);\nrobot.add(piernaIzquierda);\nrobot.add(piernaDerecha);\n\n// 7. A\u00f1adir el robot a la escena\nescena.add(robot);\n\n// 8. Funci\u00f3n de animaci\u00f3n para rotar el robot\nfunction animar() {\n    requestAnimationFrame(animar);\n\n    // Rotar todo el robot\n    robot.rotation.y += 0.01;\n\n    renderizador.render(escena, camara);\n}\n\nanimar();\n</code></pre> <p>Resultado Esperado:</p> <p>Un robot b\u00e1sico compuesto por una cabeza, cuerpo, brazos y piernas, rotando lentamente alrededor del eje Y.</p>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#67-manipulacion-de-mallas-individuales-dentro-de-un-grupo","title":"6.7 Manipulaci\u00f3n de Mallas Individuales Dentro de un Grupo","text":"<p>Cuando trabajas con grupos, puedes manipular individualmente las mallas dentro del grupo sin afectar al resto de los objetos.</p> <p>Ejemplo: Hacer que los Brazos del Robot Se Muevan Independientemente</p> <pre><code>// Suponiendo que ya tienes el grupo 'robot' con 'brazoIzquierdo' y 'brazoDerecho'\n\n// 1. Crear una funci\u00f3n para mover los brazos\nfunction moverBrazos() {\n    brazoIzquierdo.rotation.z = Math.sin(Date.now() * 0.005) * 0.5;\n    brazoDerecho.rotation.z = Math.cos(Date.now() * 0.005) * 0.5;\n}\n\n// 2. Actualizar la funci\u00f3n de animaci\u00f3n\nfunction animar() {\n    requestAnimationFrame(animar);\n\n    // Rotar todo el robot\n    robot.rotation.y += 0.01;\n\n    // Mover los brazos\n    moverBrazos();\n\n    renderizador.render(escena, camara);\n}\n\nanimar();\n</code></pre> <p>Resultado Esperado:</p> <p>Mientras el robot rota, los brazos se mueven de manera independiente, simulando un movimiento de balanceo.</p>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#68-mejores-practicas","title":"6.8 Mejores Pr\u00e1cticas","text":"<p>Uso de Helpers para Depuraci\u00f3n: Utiliza helpers como <code>THREE.AxesHelper</code>, <code>THREE.GridHelper</code> o <code>THREE.CameraHelper</code> para visualizar e inspeccionar la orientaci\u00f3n y posici\u00f3n de objetos y c\u00e1maras durante el desarrollo.</p> <p>Ejemplo: A\u00f1adir un AxesHelper y un GridHelper</p> <pre><code>   const axesHelper = new THREE.AxesHelper(5);\n   escena.add(axesHelper);\n\n   // A\u00f1adir un GridHelper para visualizar una cuadr\u00edcula en el suelo\n   const gridHelper = new THREE.GridHelper(20, 20);\n   gridHelper.position.y = -1; // Posicionar al nivel del suelo\n   escena.add(gridHelper);\n</code></pre>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#69-ejemplo-completo-escena-con-mallas-transformaciones-y-agrupacion","title":"6.9 Ejemplo Completo: Escena con Mallas, Transformaciones y Agrupaci\u00f3n","text":"<p>A continuaci\u00f3n, se presenta un ejemplo que integra todos los conceptos abordados en este tema, creando una escena con m\u00faltiples mallas, aplicando transformaciones y organiz\u00e1ndolas en grupos.</p>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#691-estructura-de-carpetas","title":"6.9.1 Estructura de Carpetas","text":"<pre><code>mi-escena-objetos-threejs/\n\u251c\u2500\u2500 index.html\n\u2514\u2500\u2500 js/\n    \u2514\u2500\u2500 three.min.js\n</code></pre>"},{"location":"Curso/6.%20Creaci%C3%B3n%20y%20Manipulaci%C3%B3n%20de%20Objetos%203D/#692-contenido-de-indexhtml","title":"6.9.2 Contenido de <code>index.html</code>","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Creaci\u00f3n y Manipulaci\u00f3n de Objetos en Three.js&lt;/title&gt;\n    &lt;style&gt;\n        body { margin: 0; }\n        canvas { display: block; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- Enlace a Three.js --&gt;\n    &lt;script src=\"js/three.min.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n        // 1. Crear la escena\n        const escena = new THREE.Scene();\n        escena.background = new THREE.Color(0xeeeeee);\n\n        // 2. Crear la c\u00e1mara\n        const camara = new THREE.PerspectiveCamera(\n            75,\n            window.innerWidth / window.innerHeight,\n            0.1,\n            1000\n        );\n        camara.position.set(0, 5, 10);\n        camara.lookAt(0, 0, 0);\n\n        // 3. Crear el renderizador\n        const renderizador = new THREE.WebGLRenderer({ antialias: true });\n        renderizador.setSize(window.innerWidth, window.innerHeight);\n        renderizador.shadowMap.enabled = true; // Habilitar sombras\n        renderizador.shadowMap.type = THREE.PCFSoftShadowMap;\n        document.body.appendChild(renderizador.domElement);\n\n        // 4. A\u00f1adir una luz ambiental\n        const ambientLight = new THREE.AmbientLight(0x404040, 1); // Luz ambiental suave\n        escena.add(ambientLight);\n\n        // 5. A\u00f1adir una luz direccional\n        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n        directionalLight.position.set(5, 10, 7.5);\n        directionalLight.castShadow = true; // La luz proyecta sombras\n\n        // Configuraci\u00f3n de sombras para la luz direccional\n        directionalLight.shadow.mapSize.width = 1024;\n        directionalLight.shadow.mapSize.height = 1024;\n        directionalLight.shadow.camera.near = 0.5;\n        directionalLight.shadow.camera.far = 50;\n        directionalLight.shadow.camera.left = -10;\n        directionalLight.shadow.camera.right = 10;\n        directionalLight.shadow.camera.top = 10;\n        directionalLight.shadow.camera.bottom = -10;\n\n        escena.add(directionalLight);\n\n        // 6. Crear un grupo de cubos rotatorios\n        const grupoCubos = new THREE.Group();\n\n        // Crear varias mallas de cubos con diferentes colores\n        const colores = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];\n        colores.forEach((color, index) =&gt; {\n            const geometria = new THREE.BoxGeometry(1, 1, 1);\n            const material = new THREE.MeshStandardMaterial({ color: color });\n            const cubo = new THREE.Mesh(geometria, material);\n            cubo.position.x = (index - 2) * 2; // Espaciarlos a lo largo del eje X\n            cubo.castShadow = true;\n            cubo.receiveShadow = true;\n            grupoCubos.add(cubo);\n        });\n\n        escena.add(grupoCubos);\n\n        // 7. Crear el suelo que recibe sombras\n        const sueloGeometria = new THREE.PlaneGeometry(20, 20);\n        const sueloMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });\n        const suelo = new THREE.Mesh(sueloGeometria, sueloMaterial);\n        suelo.rotation.x = -Math.PI / 2; // Rotar para que quede horizontal\n        suelo.position.y = -1;\n        suelo.receiveShadow = true;\n        escena.add(suelo);\n\n        // 8. Crear helpers para depuraci\u00f3n\n        const axesHelper = new THREE.AxesHelper(5);\n        escena.add(axesHelper);\n\n        const gridHelper = new THREE.GridHelper(20, 20);\n        gridHelper.position.y = -1;\n        escena.add(gridHelper);\n\n        // 9. Funci\u00f3n de animaci\u00f3n\n        function animar() {\n            requestAnimationFrame(animar);\n\n            // Rotar el grupo de cubos\n            grupoCubos.rotation.y += 0.01;\n\n            // Rotar cada cubo individualmente\n            grupoCubos.children.forEach((cubo, index) =&gt; {\n                cubo.rotation.x += 0.02;\n                cubo.rotation.y += 0.02;\n            });\n\n            renderizador.render(escena, camara);\n        }\n\n        animar();\n\n        // 10. Manejar el redimensionamiento de la ventana\n        window.addEventListener('resize', () =&gt; {\n            const ancho = window.innerWidth;\n            const alto = window.innerHeight;\n\n            renderizador.setSize(ancho, alto);\n            camara.aspect = ancho / alto;\n            camara.updateProjectionMatrix();\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Explicaci\u00f3n del C\u00f3digo:</p> <ol> <li>Escena y C\u00e1mara:</li> <li>Se crea una escena con un fondo gris claro.</li> <li>Se configura una <code>PerspectiveCamera</code> con un campo de visi\u00f3n de 75 grados, una relaci\u00f3n de aspecto basada en el tama\u00f1o de la ventana y planos de recorte cercanos y lejanos de 0.1 y 1000, respectivamente.</li> <li> <p>La c\u00e1mara se posiciona en <code>(0, 5, 10)</code> y mira hacia el centro de la escena.</p> </li> <li> <p>Renderizador:</p> </li> <li>Se crea un <code>WebGLRenderer</code> con antialiasing habilitado para suavizar los bordes de los objetos.</li> <li>Se habilitan las sombras y se configura el tipo de sombra (<code>PCFSoftShadowMap</code>) para obtener sombras m\u00e1s suaves.</li> <li> <p>El renderizador se ajusta al tama\u00f1o de la ventana y se a\u00f1ade al documento HTML.</p> </li> <li> <p>Iluminaci\u00f3n:</p> </li> <li>AmbientLight: Proporciona una iluminaci\u00f3n base suave en toda la escena.</li> <li> <p>DirectionalLight: Simula una luz direccional (como el sol), posicionada en <code>(5, 10, 7.5)</code> y configurada para proyectar sombras. Se ajustan sus propiedades de sombra para mejorar la calidad visual.</p> </li> <li> <p>Grupo de Cubos:</p> </li> <li>Se crea un grupo (<code>THREE.Group</code>) que contiene varios cubos de diferentes colores.</li> <li>Cada cubo se posiciona a lo largo del eje X para espaciarlo.</li> <li>Los cubos est\u00e1n configurados para proyectar y recibir sombras.</li> <li> <p>El grupo completo se a\u00f1ade a la escena.</p> </li> <li> <p>Suelo:</p> </li> <li>Se crea un plano grande que act\u00faa como suelo, rotado para quedar horizontal y posicionado debajo de los cubos.</li> <li> <p>El suelo est\u00e1 configurado para recibir sombras.</p> </li> <li> <p>Helpers para Depuraci\u00f3n:</p> </li> <li>AxesHelper: Visualiza los ejes X, Y y Z en la escena.</li> <li> <p>GridHelper: Muestra una cuadr\u00edcula en el suelo para facilitar la percepci\u00f3n de la escala y la posici\u00f3n de los objetos.</p> </li> <li> <p>Animaci\u00f3n:</p> </li> <li>Se define una funci\u00f3n <code>animar</code> que rota el grupo de cubos alrededor del eje Y y, adem\u00e1s, rota cada cubo individualmente alrededor de sus ejes X e Y.</li> <li> <p>La funci\u00f3n se llama en cada frame utilizando <code>requestAnimationFrame</code> para crear una animaci\u00f3n fluida.</p> </li> <li> <p>Redimensionamiento:</p> </li> <li>Se a\u00f1ade un evento que ajusta el tama\u00f1o del renderizador y la c\u00e1mara cuando la ventana cambia de tama\u00f1o, manteniendo la proporci\u00f3n y la calidad visual.</li> </ol> <p>Resultado Esperado:</p> <p>Una escena con varios cubos de colores diferentes agrupados y rotando juntos alrededor del eje Y, mientras que cada cubo tambi\u00e9n rota individualmente. El suelo y los helpers proporcionan una referencia visual clara de la orientaci\u00f3n y escala de los objetos.</p>"}]}